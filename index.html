<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LabCAD Web Pro - 實驗室規劃系統</title>

  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root{
      --bg-dark:#0f172a; --bg-sidebar:#1e293b; --primary:#3b82f6; --accent:#10b981; --danger:#ef4444; --border:#334155; --text:#f1f5f9;
    }
    body{ margin:0; font-family:'Segoe UI',system-ui; background:var(--bg-dark); color:var(--text); overflow:hidden; }
    .app{ display:grid; grid-template-columns:280px 1fr 320px; height:100vh; }
    .sidebar{ background:var(--bg-sidebar); border-right:1px solid var(--border); display:flex; flex-direction:column; overflow:auto; }
    .sidebar-header{ padding:20px; background:#111827; font-weight:bold; border-bottom:1px solid var(--border); position:sticky; top:0; z-index:2; }
    .tool-section{ padding:15px; border-bottom:1px solid var(--border); }
    .tool-section-title{ font-size:12px; letter-spacing:.08em; color:#94a3b8; text-transform:uppercase; margin-bottom:10px; }
    .item{ background:#334155; padding:10px; border-radius:6px; cursor:pointer; text-align:center; font-size:.8rem; margin-bottom:8px; user-select:none; }
    .item:hover{ background:#475569; border:1px solid var(--primary); }

    .canvas-area{ position:relative; background:#f1f5f9; }
    #container,#three-container{ width:100%; height:100%; }
    #three-container{ position:absolute; top:0; left:0; display:none; z-index:60; background:#0a0f1a; }

    .toolbar{
      position:absolute; top:20px; left:50%; transform:translateX(-50%);
      background:rgba(30,41,59,.95); padding:8px 16px; border-radius:50px;
      display:flex; gap:12px; z-index:100; border:1px solid var(--border);
      align-items:center;
    }
    .tool-btn{ background:none; border:none; color:#cbd5e1; cursor:pointer; display:flex; align-items:center; }
    .tool-btn:hover{ color:#fff; }
    .tool-divider{ width:1px; height:18px; background:rgba(148,163,184,.35); margin:0 2px; }

    .inspector{ background:#1e293b; border-left:1px solid var(--border); padding:20px; color:#cbd5e1; overflow:auto; }
    .prop-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:15px; }
    .prop-group{ display:flex; flex-direction:column; gap:4px; }
    .prop-label{ font-size:.7rem; color:#94a3b8; text-transform:uppercase; }
    input{ background:#0f172a; border:1px solid #334155; color:#fff; padding:8px; border-radius:6px; font-size:.9rem; }

    .btn-action{
      color:#fff; border:none; padding:10px; border-radius:8px; cursor:pointer; font-weight:bold;
      width:100%; margin-top:12px; display:flex; align-items:center; justify-content:center; gap:5px;
    }

    #debug3d{
      position:absolute; right:10px; bottom:10px; z-index:200;
      background:rgba(15,23,42,.85); color:#e2e8f0; font-size:12px;
      padding:8px 10px; border:1px solid rgba(148,163,184,.35);
      border-radius:8px; display:none; white-space:pre;
    }

    #toast{
      position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(15,23,42,.9); color:#e2e8f0; font-size:13px;
      padding:8px 12px; border-radius:10px; border:1px solid rgba(148,163,184,.25);
      z-index:300; display:none;
    }

    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      background:rgba(148,163,184,.12);
      border:1px solid rgba(148,163,184,.25);
      color:#e2e8f0; font-size:12px;
      user-select:none;
    }
    .toggle{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px; border-radius:10px;
      border:1px solid rgba(148,163,184,.2);
      background:rgba(15,23,42,.35);
      margin-top:10px;
    }
    .toggle input{ width:auto; }
    .align-grid{ display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:10px; }
    .small-btn{
      width:100%;
      background:#0f172a;
      border:1px solid rgba(148,163,184,.25);
      color:#e2e8f0;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:12px;
    }
    .small-btn:hover{ border-color: rgba(59,130,246,.7); }

    /* 3D info card */
    #info-card{
      position:absolute;
      min-width: 240px;
      max-width: 320px;
      pointer-events:none;
      z-index: 250;
      display:none;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(96, 165, 250, 0.55);
      border-radius: 14px;
      padding: 12px 14px;
      color: #e2e8f0;
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .info-title{ font-weight:700; font-size:16px; margin-bottom:10px; display:flex; align-items:center; gap:10px; }
    .info-icon{
      width:34px; height:34px; border-radius:10px;
      background: rgba(59,130,246,0.18);
      border: 1px solid rgba(59,130,246,0.45);
      display:flex; align-items:center; justify-content:center;
      color:#93c5fd;
      font-weight:800;
    }
    .info-row{
      display:flex; justify-content:space-between; gap:14px;
      padding:6px 0;
      border-top: 1px solid rgba(148,163,184,0.16);
      font-size:13px;
    }
    .info-row:first-of-type{ border-top:none; }
    .info-key{ color:#94a3b8; }

    .hint{
      color:#94a3b8; font-size:12px; line-height:1.35; margin-top:10px;
    }
  </style>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="sidebar-header">LabCAD Web Pro</div>

    <div class="tool-section">
      <div class="tool-section-title">房間</div>
      <div class="item" onclick="focusRoomSettings()">房間設定（寬/長/牆高）</div>
    </div>

    <div class="tool-section">
      <div class="tool-section-title">區域</div>
      <div class="item" onclick="addZone('新規劃區域')">新增區域</div>
    </div>

    <div class="tool-section" id="device-catalog">
      <div class="tool-section-title">設備</div>
      <div style="color:#94a3b8;font-size:12px;">載入中...</div>
    </div>

    <div style="margin-top:auto; padding:20px; position:sticky; bottom:0; background:linear-gradient(180deg, rgba(30,41,59,0), rgba(30,41,59,1) 30%);">
      <button class="btn-action" style="background:var(--accent);" id="toggle-3d" onclick="toggle3D()">查看 3D 預覽</button>
      <div class="hint" style="margin-top:10px;">
        單位：1格=10cm=100mm（格線10px）<br/>
        3D：點選物件可反選到2D（Shift可多選）
      </div>
    </div>
  </aside>

  <main class="canvas-area">
    <div class="toolbar" title="工具列">
      <button class="tool-btn" onclick="exportImg('png')" title="匯出 PNG"><i data-lucide="image"></i></button>
      <button class="tool-btn" onclick="exportImg('pdf')" title="匯出 PDF"><i data-lucide="file-text"></i></button>
      <button class="tool-btn" onclick="deleteSelected()" title="刪除選取"><i data-lucide="trash-2"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" onclick="exportDesignJSON()" title="匯出設計 JSON"><i data-lucide="download"></i></button>
      <button class="tool-btn" onclick="triggerImportJSON()" title="匯入設計 JSON"><i data-lucide="upload"></i></button>
      <input id="import-json-input" type="file" accept="application/json" style="display:none" />
      <button class="tool-btn" onclick="resetDesign(true)" title="重置 / 清空"><i data-lucide="rotate-ccw"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" onclick="toggleGrid()" title="顯示/隱藏格線"><i data-lucide="grid-3x3"></i></button>
      <button class="tool-btn" onclick="toggleSnap()" title="吸附格線"><i data-lucide="magnet"></i></button>
    </div>

    <div id="container"></div>
    <div id="three-container"></div>
    <div id="debug3d"></div>
    <div id="toast"></div>
    <div id="info-card"></div>
  </main>

  <aside class="inspector">
    <h3 id="ins-title">屬性</h3>
    <div id="inspector-content">請選擇物件</div>
  </aside>
</div>

<script>
/* ===========================
 * Helpers / UI
 * =========================== */
lucide.createIcons();

function toast(msg, ms = 1200){
  const el = document.getElementById('toast');
  if(!el) return;
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(el._t);
  el._t = setTimeout(() => el.style.display = 'none', ms);
}

function safeInt(v, fallback=0){
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
}

function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

/* ===========================
 * Units (Stage 5)
 * =========================== */
/** UI grid: 10px per grid */
const GRID_PX = 10;
/** 1 grid = 100mm */
const MM_PER_GRID = 100;
/** Derived */
const MM_PER_PX = MM_PER_GRID / GRID_PX; // 10mm per px

function pxToMm(px){ return Math.round(px * MM_PER_PX); }
function mmToPx(mm){ return mm / MM_PER_PX; }
function mmToCm(mm){ return (mm / 10); } // 10mm = 1cm

function fmtMm(mm){ return `${Math.round(mm)}mm`; }
function fmtCm(mm){ return `${Math.round(mmToCm(mm))}cm`; }

/* ===========================
 * Room settings (Stage 5)
 * =========================== */
const ROOM = {
  widthMm: 6000,   // 6m
  depthMm: 4000,   // 4m
  wallHeightMm: 2800,
  wallThicknessMm: 100
};

function focusRoomSettings(){
  // show inspector room settings panel
  selectedNodes = [];
  selectedNode = null;
  tr.nodes([]);
  renderInspector('room');
  layer.draw();
  if(is3DVisible()) update3D();
}

/* ===========================
 * Device Catalog
 * =========================== */
const DEVICE_CATALOG = [
  { key:'bench', name:'實驗桌', wMm: 1200, dMm: 600,  hMm: 800,  color:'#3b82f6' },
  { key:'hood',  name:'排煙櫃', wMm: 1000, dMm: 800,  hMm: 2000, color:'#ef4444' },
  { key:'sink',  name:'洗滌槽', wMm: 900,  dMm: 600,  hMm: 900,  color:'#22c55e' },
  { key:'fridge', name:'冰箱', wMm: 700,  dMm: 700,  hMm: 1800, color:'#60a5fa' },
  { key:'centrifuge', name:'離心機', wMm: 600, dMm: 600, hMm: 900, color:'#f59e0b' },
  { key:'ultra_low_freezer', name:'超低溫冰箱', wMm: 800, dMm: 800, hMm: 2000, color:'#38bdf8' },
  { key:'incubator', name:'培養箱', wMm: 700, dMm: 600, hMm: 1600, color:'#a78bfa' },
];

const DEVICE_BY_NAME = new Map(DEVICE_CATALOG.map(d => [d.name, d]));
const DEVICE_BY_KEY = new Map(DEVICE_CATALOG.map(d => [d.key, d]));

function renderDeviceCatalog(){
  const section = document.getElementById('device-catalog');
  if(!section) return;
  const title = section.querySelector('.tool-section-title');
  section.innerHTML = '';
  section.appendChild(title);

  DEVICE_CATALOG.forEach(d => {
    const div = document.createElement('div');
    div.className = 'item';
    div.textContent = d.name;
    div.onclick = () => addDeviceFromCatalog(d.key);
    section.appendChild(div);
  });
}

function addDeviceFromCatalog(key){
  const d = DEVICE_BY_KEY.get(key);
  if(!d) return;
  addDevice(d.name, mmToPx(d.wMm), mmToPx(d.dMm), mmToPx(d.hMm), d.color, d.key);
}

/* ===========================
 * Konva 2D
 * =========================== */
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth - 600,
  height: window.innerHeight
});

const gridLayer = new Konva.Layer();
const layer = new Konva.Layer();
stage.add(gridLayer);
stage.add(layer);

const tr = new Konva.Transformer({ keepRatio: false });
layer.add(tr);

let selectedNodes = [];
let selectedNode = null;

/* ---- Grid / Snap ---- */
let gridVisible = true;
let snapEnabled = true;

function toggleGrid(){
  gridVisible = !gridVisible;
  drawGrid();
  toast(gridVisible ? '格線：顯示' : '格線：隱藏');
}
function toggleSnap(){
  snapEnabled = !snapEnabled;
  toast(snapEnabled ? '吸附：開啟' : '吸附：關閉');
}
function snapPx(v){ return Math.round(v / GRID_PX) * GRID_PX; }

function drawGrid(){
  gridLayer.destroyChildren();
  if(!gridVisible){ gridLayer.draw(); return; }

  const w = stage.width();
  const h = stage.height();

  for(let x=0; x<=w; x+=GRID_PX){
    gridLayer.add(new Konva.Line({ points:[x,0,x,h], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  }
  for(let y=0; y<=h; y+=GRID_PX){
    gridLayer.add(new Konva.Line({ points:[0,y,w,y], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  }
  gridLayer.draw();
}

/* ===========================
 * Room boundary in 2D
 * =========================== */
let roomRect2D = null;

function drawRoomBoundary2D(){
  if(roomRect2D) roomRect2D.destroy();

  const wPx = mmToPx(ROOM.widthMm);
  const dPx = mmToPx(ROOM.depthMm);

  roomRect2D = new Konva.Rect({
    x: snapPx((stage.width() - wPx) / 2),
    y: snapPx((stage.height() - dPx) / 2),
    width: wPx,
    height: dPx,
    stroke: 'rgba(15,23,42,0.45)',
    strokeWidth: 2,
    fill: 'rgba(15,23,42,0.03)',
    listening: false,
    name: 'room-boundary'
  });

  // Put on grid layer (behind)
  gridLayer.add(roomRect2D);
  gridLayer.draw();
}

function getRoomRectPx(){
  if(!roomRect2D) drawRoomBoundary2D();
  return roomRect2D.getClientRect();
}

/* ===========================
 * Selection rectangle
 * =========================== */
let selecting = false;
let selectionRect;
let startPos = null;

function initSelectionRect(){
  selectionRect = new Konva.Rect({
    x: 0, y: 0, width: 0, height: 0,
    fill: 'rgba(59,130,246,0.12)',
    stroke: 'rgba(59,130,246,0.9)',
    strokeWidth: 1,
    visible: false,
    listening: false
  });
  layer.add(selectionRect);
}
initSelectionRect();

/* ===========================
 * Nodes CRUD
 * =========================== */
function addZone(name){
  createNode('zone', name, mmToPx(3000), mmToPx(2000), 0, 'rgba(59, 130, 246, 0.1)', '#3b82f6', 'zone');
}

/**
 * addDevice(name, wPx, dPx, hPx, color, deviceKey?)
 * hPx is stored as height3d in px-space; displayed in mm/cm by conversion.
 */
function addDevice(name, wPx, dPx, hPx, color, deviceKey){
  createNode('device', name, wPx, dPx, hPx, color, '#1e293b', deviceKey || 'device');
}

function createNode(type, name, wPx, dPx, hPx, fill, stroke, deviceKey){
  const group = new Konva.Group({
    x: 100, y: 100, draggable: true, name: type,
    customData: {
      height3dPx: hPx || 0,
      deviceKey: deviceKey || (type === 'zone' ? 'zone' : 'device')
    }
  });

  const rect = new Konva.Rect({
    width: wPx, height: dPx, fill, stroke,
    name: 'main-rect',
    dash: type === 'zone' ? [10,5] : []
  });

  const title = new Konva.Text({
    text: name, fontSize: 14, fill: stroke,
    padding: 8, name: 'title-text'
  });

  const dim = new Konva.Text({
    text: '', fontSize: 10, fill: stroke, name: 'dim-label'
  });

  group.add(rect, title, dim);
  updateUI(group);

  group.on('dragmove', () => {
    if(snapEnabled) group.position({ x: snapPx(group.x()), y: snapPx(group.y()) });
    constrainToRoom(group);
    updateUI(group);
    scheduleAutosave();
  });
  group.on('dragend', () => scheduleAutosave());

  group.on('transform', () => { updateUI(group); scheduleAutosave(); });
  group.on('transformend', () => {
    if(snapEnabled) normalizeGroupToGrid(group);
    constrainToRoom(group);
    scheduleAutosave();
    if(is3DVisible()) update3D();
  });

  group.on('click tap', (e) => {
    e.cancelBubble = true;
    const multi = e.evt && e.evt.shiftKey;
    if(multi) toggleSelectNode(group);
    else selectSingleNode(group);
  });

  layer.add(group);
  if(type === 'zone') group.moveToBottom();

  selectSingleNode(group);
  layer.draw();

  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function normalizeGroupToGrid(group){
  group.x(snapPx(group.x()));
  group.y(snapPx(group.y()));

  const rect = group.findOne('.main-rect');
  const absW = rect.width() * group.scaleX();
  const absH = rect.height() * group.scaleY();

  const targetW = Math.max(GRID_PX, snapPx(absW));
  const targetH = Math.max(GRID_PX, snapPx(absH));

  group.scaleX(targetW / rect.width());
  group.scaleY(targetH / rect.height());
}

function constrainToRoom(group){
  if(!roomRect2D) return;
  const rr = getRoomRectPx();

  const r = group.findOne('.main-rect');
  const w = r.width() * group.scaleX();
  const h = r.height() * group.scaleY();

  let x = group.x();
  let y = group.y();

  x = clamp(x, rr.x, rr.x + rr.width - w);
  y = clamp(y, rr.y, rr.y + rr.height - h);

  group.position({ x, y });
}

function updateUI(group){
  const rect = group.findOne('.main-rect');
  const dim = group.findOne('.dim-label');
  const wPx = rect.width() * group.scaleX();
  const dPx = rect.height() * group.scaleY();

  dim.text(`${fmtMm(pxToMm(wPx))} x ${fmtMm(pxToMm(dPx))}`);
  dim.x(rect.width() - dim.width() - 5);
  dim.y(rect.height() - 15);

  if(selectedNodes.includes(group)) renderInspector();
}

/* ===========================
 * Selection model
 * =========================== */
function applyTransformer(){
  tr.nodes(selectedNodes);
  layer.draw();
  sync3DSelectionHighlight();
}

function clearSelection(){
  selectedNodes = [];
  selectedNode = null;
  applyTransformer();
  renderInspector();
}

function selectSingleNode(node){
  selectedNodes = [node];
  selectedNode = node;
  applyTransformer();
  renderInspector();
}

function toggleSelectNode(node){
  const idx = selectedNodes.indexOf(node);
  if(idx >= 0) selectedNodes.splice(idx, 1);
  else selectedNodes.push(node);

  selectedNode = selectedNodes.length === 1 ? selectedNodes[0] : null;
  applyTransformer();
  renderInspector();
}

stage.on('click tap', (e) => {
  if(e.target === stage){
    clearSelection();
    if(is3DVisible()) update3D();
  }
});

stage.on('mousedown touchstart', (e) => {
  if(is3DVisible()) return;
  if(e.target !== stage) return;
  if(e.evt && (e.evt.button !== undefined) && e.evt.button !== 0) return;

  selecting = true;
  startPos = stage.getPointerPosition();
  selectionRect.visible(true);
  selectionRect.position(startPos);
  selectionRect.size({ width: 0, height: 0 });
  layer.draw();
});

stage.on('mousemove touchmove', () => {
  if(!selecting) return;
  const pos = stage.getPointerPosition();
  if(!pos) return;

  const x = Math.min(startPos.x, pos.x);
  const y = Math.min(startPos.y, pos.y);
  const w = Math.abs(pos.x - startPos.x);
  const h = Math.abs(pos.y - startPos.y);

  selectionRect.setAttrs({ x, y, width: w, height: h });
  layer.batchDraw();
});

stage.on('mouseup touchend', (e) => {
  if(!selecting) return;
  selecting = false;

  selectionRect.visible(false);
  layer.draw();

  const box = selectionRect.getClientRect();
  const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));
  const additive = e.evt && e.evt.shiftKey;

  const hits = groups.filter(g => Konva.Util.haveIntersection(box, g.getClientRect()));
  if(!additive) selectedNodes = [];
  hits.forEach(g => { if(!selectedNodes.includes(g)) selectedNodes.push(g); });

  selectedNode = selectedNodes.length === 1 ? selectedNodes[0] : null;
  applyTransformer();
  renderInspector();
  if(is3DVisible()) update3D();
});

/* ===========================
 * Inspector rendering
 * =========================== */
function renderInspector(mode){
  const container = document.getElementById('inspector-content');

  if(mode === 'room'){
    container.innerHTML = `
      <div class="chip">矩形房間設定</div>

      <div class="prop-grid" style="margin-top:12px;">
        <div class="prop-group">
          <label class="prop-label">寬度 (mm)</label>
          <input type="number" value="${ROOM.widthMm}" oninput="updateRoom('widthMm', this.value)">
        </div>
        <div class="prop-group">
          <label class="prop-label">長度 (mm)</label>
          <input type="number" value="${ROOM.depthMm}" oninput="updateRoom('depthMm', this.value)">
        </div>
        <div class="prop-group">
          <label class="prop-label">牆高 (mm)</label>
          <input type="number" value="${ROOM.wallHeightMm}" oninput="updateRoom('wallHeightMm', this.value)">
        </div>
        <div class="prop-group">
          <label class="prop-label">牆厚 (mm)</label>
          <input type="number" value="${ROOM.wallThicknessMm}" disabled>
        </div>
      </div>

      <div class="hint" style="margin-top:10px;">
        房間會在 2D 顯示邊界，物件拖曳會限制在房間內。<br/>
        3D 會生成地板與四面牆。
      </div>

      <button class="btn-action" style="background:#334155" onclick="toast('已套用房間設定');">完成</button>
    `;
    return;
  }

  if(selectedNodes.length === 0){
    container.innerHTML = `
      <div class="chip">請選擇物件</div>
      <div class="hint">提示：左鍵拖曳空白處可框選，Shift 可多選。</div>
    `;
    return;
  }

  if(selectedNodes.length > 1){
    container.innerHTML = `
      <div class="chip">已選取：${selectedNodes.length} 個物件</div>
      <div class="toggle">
        <div><div class="prop-label">格線</div><div style="font-size:12px;color:#94a3b8;">格距：10cm</div></div>
        <input type="checkbox" ${gridVisible ? 'checked' : ''} onchange="toggleGrid()">
      </div>
      <div class="toggle">
        <div><div class="prop-label">吸附</div><div style="font-size:12px;color:#94a3b8;">對齊格線</div></div>
        <input type="checkbox" ${snapEnabled ? 'checked' : ''} onchange="toggleSnap()">
      </div>
      <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除選取 (${selectedNodes.length})</button>
    `;
    return;
  }

  const n = selectedNodes[0];
  const r = n.findOne('.main-rect');
  const wPx = r.width() * n.scaleX();
  const dPx = r.height() * n.scaleY();
  const hPx = n.attrs.customData?.height3dPx || 0;

  const key = n.attrs.customData?.deviceKey || n.name();
  const sizeText = `${fmtMm(pxToMm(wPx))}×${fmtMm(pxToMm(dPx))}`;

  container.innerHTML = `
    <div class="chip">已選取：1 個物件（Shift 可多選）</div>

    <div class="prop-row" style="margin-top:12px;">
      <label class="prop-label">名稱</label>
      <input type="text" value="${n.findOne('.title-text').text()}" oninput="updateProp('name', this.value)">
    </div>

    <div class="prop-grid">
      <div class="prop-group"><label class="prop-label">X (mm)</label><input type="number" value="${pxToMm(n.x())}" oninput="updateProp('xMm', this.value)"></div>
      <div class="prop-group"><label class="prop-label">Y (mm)</label><input type="number" value="${pxToMm(n.y())}" oninput="updateProp('yMm', this.value)"></div>
      <div class="prop-group"><label class="prop-label">寬 (mm)</label><input type="number" value="${pxToMm(wPx)}" oninput="updateProp('wMm', this.value)"></div>
      <div class="prop-group"><label class="prop-label">深 (mm)</label><input type="number" value="${pxToMm(dPx)}" oninput="updateProp('dMm', this.value)"></div>
      <div class="prop-group"><label class="prop-label">旋轉 (deg)</label><input type="number" value="${Math.round(n.rotation())}" oninput="updateProp('rot', this.value)"></div>
      <div class="prop-group"><label class="prop-label">高度 (mm)</label><input type="number" value="${pxToMm(hPx)}" oninput="updateProp('hMm', this.value)"></div>
    </div>

    <div class="hint">
      類別：<b>${key}</b><br/>
      尺寸：<b>${sizeText}</b> / 擺放高度：<b>${fmtCm(pxToMm(hPx))}</b>
    </div>

    <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除物件</button>
  `;
}

function updateRoom(p, v){
  const mm = Math.max(1000, safeInt(v, ROOM[p])); // minimum 1m
  ROOM[p] = mm;
  drawGrid();
  drawRoomBoundary2D();
  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function updateProp(p, v){
  if(selectedNodes.length !== 1) return;
  const node = selectedNodes[0];

  if(p === 'name') node.findOne('.title-text').text(v);

  if(p === 'xMm') node.x(snapEnabled ? snapPx(mmToPx(safeInt(v))) : mmToPx(safeInt(v)));
  if(p === 'yMm') node.y(snapEnabled ? snapPx(mmToPx(safeInt(v))) : mmToPx(safeInt(v)));

  if(p === 'wMm'){
    const rect = node.findOne('.main-rect');
    const baseW = rect.width();
    let targetPx = mmToPx(Math.max(100, safeInt(v, pxToMm(baseW))));
    if(snapEnabled) targetPx = Math.max(GRID_PX, snapPx(targetPx));
    node.scaleX(targetPx / baseW);
  }

  if(p === 'dMm'){
    const rect = node.findOne('.main-rect');
    const baseH = rect.height();
    let targetPx = mmToPx(Math.max(100, safeInt(v, pxToMm(baseH))));
    if(snapEnabled) targetPx = Math.max(GRID_PX, snapPx(targetPx));
    node.scaleY(targetPx / baseH);
  }

  if(p === 'rot') node.rotation(safeInt(v));
  if(p === 'hMm') node.attrs.customData.height3dPx = mmToPx(Math.max(0, safeInt(v)));

  if(snapEnabled) normalizeGroupToGrid(node);
  constrainToRoom(node);

  updateUI(node);
  layer.draw();

  scheduleAutosave();
  if(is3DVisible()) update3D();
}

/* ===========================
 * Delete / Export
 * =========================== */
function deleteSelected(){
  if(selectedNodes.length === 0) return;

  selectedNodes.forEach(n => n.destroy());
  selectedNodes = [];
  selectedNode = null;
  tr.nodes([]);
  renderInspector();
  layer.draw();

  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function exportImg(f){
  tr.nodes([]);
  layer.draw();

  if(f === 'png'){
    const l = document.createElement('a');
    l.download = 'lab.png';
    l.href = stage.toDataURL();
    l.click();
  }else{
    const doc = new jspdf.jsPDF('l', 'px', [stage.width(), stage.height()]);
    doc.addImage(stage.toDataURL(), 'PNG', 0, 0, stage.width(), stage.height());
    doc.save('lab.pdf');
  }
}

/* ===========================
 * Save/Load
 * =========================== */
const STORAGE_KEY = 'labcad_design_v1';
let autosaveTimer = null;

function scheduleAutosave(){
  clearTimeout(autosaveTimer);
  autosaveTimer = setTimeout(() => saveDesignToLocalStorage(), 150);
}

function serializeNode(group){
  const r = group.findOne('.main-rect');
  const title = group.findOne('.title-text');
  const wPx = r.width() * group.scaleX();
  const dPx = r.height() * group.scaleY();
  const hPx = group.attrs.customData?.height3dPx || 0;

  return {
    type: group.name(),
    key: group.attrs.customData?.deviceKey || group.name(),
    name: title ? title.text() : '',
    xMm: pxToMm(group.x()),
    yMm: pxToMm(group.y()),
    wMm: pxToMm(wPx),
    dMm: pxToMm(dPx),
    rot: group.rotation(),
    fill: r.fill(),
    stroke: r.stroke(),
    dash: r.dash(),
    hMm: pxToMm(hPx)
  };
}

function getDesignJSON(){
  const nodes = layer.getChildren()
    .filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'))
    .map(serializeNode);

  return {
    version: 5,
    savedAt: new Date().toISOString(),
    units: { gridPx: GRID_PX, mmPerGrid: MM_PER_GRID },
    room: { ...ROOM },
    ui: { gridVisible, snapEnabled },
    nodes
  };
}

function saveDesignToLocalStorage(){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(getDesignJSON()));
  }catch(err){
    console.error(err);
    toast('自動保存失敗（localStorage）');
  }
}

function resetDesign(alsoClearLocalStorage=false){
  const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));
  groups.forEach(g => g.destroy());
  selectionRect.visible(false);

  clearSelection();
  layer.draw();

  if(alsoClearLocalStorage){
    localStorage.removeItem(STORAGE_KEY);
    toast('已清空設計');
  }else{
    scheduleAutosave();
  }

  if(is3DVisible()) update3D();
}

function loadDesignFromObject(design){
  if(!design || !Array.isArray(design.nodes)) throw new Error('Invalid design format');

  resetDesign(false);

  if(design.room){
    ROOM.widthMm = design.room.widthMm ?? ROOM.widthMm;
    ROOM.depthMm = design.room.depthMm ?? ROOM.depthMm;
    ROOM.wallHeightMm = design.room.wallHeightMm ?? ROOM.wallHeightMm;
    ROOM.wallThicknessMm = design.room.wallThicknessMm ?? ROOM.wallThicknessMm;
  }
  if(design.ui){
    gridVisible = design.ui.gridVisible ?? gridVisible;
    snapEnabled = design.ui.snapEnabled ?? snapEnabled;
  }

  design.nodes.forEach(n => {
    const type = n.type === 'zone' ? 'zone' : 'device';
    const stroke = n.stroke || (type==='zone' ? '#3b82f6' : '#1e293b');
    const dash = Array.isArray(n.dash) ? n.dash : (type==='zone' ? [10,5] : []);
    const fill = n.fill || (type==='zone' ? 'rgba(59, 130, 246, 0.1)' : '#3b82f6');

    const group = new Konva.Group({
      x: mmToPx(Number(n.xMm) || 0),
      y: mmToPx(Number(n.yMm) || 0),
      draggable: true,
      name: type,
      customData: {
        height3dPx: mmToPx(Number(n.hMm) || 0),
        deviceKey: n.key || (type==='zone' ? 'zone' : 'device')
      }
    });

    const rect = new Konva.Rect({
      width: mmToPx(Math.max(100, Number(n.wMm) || 1000)),
      height: mmToPx(Math.max(100, Number(n.dMm) || 1000)),
      fill,
      stroke,
      name: 'main-rect',
      dash
    });

    const title = new Konva.Text({
      text: n.name || '',
      fontSize: 14,
      fill: stroke,
      padding: 8,
      name: 'title-text'
    });

    const dim = new Konva.Text({ text: '', fontSize: 10, fill: stroke, name: 'dim-label' });

    group.rotation(Number(n.rot) || 0);
    group.add(rect, title, dim);
    updateUI(group);

    group.on('dragmove', () => {
      if(snapEnabled) group.position({ x: snapPx(group.x()), y: snapPx(group.y()) });
      constrainToRoom(group);
      updateUI(group);
      scheduleAutosave();
    });
    group.on('dragend', () => scheduleAutosave());
    group.on('transform', () => { updateUI(group); scheduleAutosave(); });
    group.on('transformend', () => {
      if(snapEnabled) normalizeGroupToGrid(group);
      constrainToRoom(group);
      scheduleAutosave();
      if(is3DVisible()) update3D();
    });
    group.on('click tap', (e) => {
      e.cancelBubble = true;
      const multi = e.evt && e.evt.shiftKey;
      if(multi) toggleSelectNode(group);
      else selectSingleNode(group);
    });

    layer.add(group);
    if(type === 'zone') group.moveToBottom();
  });

  drawGrid();
  drawRoomBoundary2D();
  layer.draw();

  scheduleAutosave();
  if(is3DVisible()) update3D();

  toast('已載入設計');
}

function tryLoadFromLocalStorage(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{
    loadDesignFromObject(JSON.parse(raw));
    toast('已從自動保存載入');
  }catch(err){
    console.warn('Failed to load autosave:', err);
  }
}

function downloadText(filename, text, mime='application/json'){
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function exportDesignJSON(){
  downloadText('labcad-design.json', JSON.stringify(getDesignJSON(), null, 2));
  toast('已匯出 JSON');
}

function triggerImportJSON(){ document.getElementById('import-json-input').click(); }

document.getElementById('import-json-input').addEventListener('change', (e) => {
  const file = e.target.files && e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    try{
      loadDesignFromObject(JSON.parse(reader.result));
      toast('已匯入 JSON');
    }catch(err){
      console.error(err);
      toast('匯入失敗：JSON 格式不正確');
    }finally{
      e.target.value = '';
    }
  };
  reader.readAsText(file);
});

/* ===========================
 * 3D Engine (Raycaster + info card + room)
 * =========================== */
let sc, cam, rend, ctrl;
let objectsGroup;
let groundMesh;
let dirLight;
let roomGroup3D;

const threeMap = new Map(); // konvaId -> { root, mesh, edges, ... }
const pickables = [];       // meshes used for raycasting

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function is3DVisible(){
  const c3d = document.getElementById('three-container');
  return c3d && c3d.style.display === 'block';
}

function get3DSize(){
  const c3d = document.getElementById('three-container');
  return { w: Math.max(1, c3d.clientWidth || 0), h: Math.max(1, c3d.clientHeight || 0) };
}

function resize3D(){
  if(!rend || !cam) return;
  const { w, h } = get3DSize();
  rend.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  rend.setSize(w, h, false);
  cam.aspect = w / h;
  cam.updateProjectionMatrix();
  updateDebug3D();
}

function init3DIfNeeded(){
  const c3d = document.getElementById('three-container');
  if(sc) return;

  sc = new THREE.Scene();
  sc.background = new THREE.Color(0x0a0f1a);

  const { w, h } = get3DSize();
  cam = new THREE.PerspectiveCamera(45, w / h, 1, 20000);
  cam.position.set(1000, 1000, 1000);

  rend = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  rend.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  rend.setSize(w, h, false);
  rend.shadowMap.enabled = true;
  rend.shadowMap.type = THREE.PCFSoftShadowMap;
  c3d.appendChild(rend.domElement);

  ctrl = new THREE.OrbitControls(cam, rend.domElement);
  ctrl.enableDamping = true;
  ctrl.dampingFactor = 0.08;
  ctrl.target.set(0, 0, 0);
  ctrl.update();

  sc.add(new THREE.AmbientLight(0xffffff, 0.55));

  dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(1200, 1800, 900);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 12000;
  dirLight.shadow.camera.left = -5000;
  dirLight.shadow.camera.right = 5000;
  dirLight.shadow.camera.top = 5000;
  dirLight.shadow.camera.bottom = -5000;
  sc.add(dirLight);

  const groundGeo = new THREE.PlaneGeometry(12000, 12000);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.95, metalness: 0.0 });
  groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI / 2;
  groundMesh.position.y = 0;
  groundMesh.receiveShadow = true;
  sc.add(groundMesh);

  sc.add(new THREE.GridHelper(8000, 80, 0x334155, 0x1e293b));
  sc.add(new THREE.AxesHelper(200));

  roomGroup3D = new THREE.Group();
  roomGroup3D.name = 'roomGroup3D';
  sc.add(roomGroup3D);

  objectsGroup = new THREE.Group();
  objectsGroup.name = 'objectsGroup';
  sc.add(objectsGroup);

  // raycaster events
  rend.domElement.addEventListener('pointerdown', onPointerDown3D);

  updateDebug3D();
}

function toggle3D(){
  const btn = document.getElementById('toggle-3d');
  const c2d = document.getElementById('container');
  const c3d = document.getElementById('three-container');
  const debug = document.getElementById('debug3d');

  const opening = (c3d.style.display === 'none' || c3d.style.display === '');

  if(opening){
    c3d.style.display = 'block';
    c2d.style.display = 'none';
    btn.innerText = '返回 2D';
    if(debug) debug.style.display = 'block';

    requestAnimationFrame(() => {
      init3DIfNeeded();
      resize3D();
      update3D();
      animate3D();
    });
  }else{
    hideInfoCard();
    c3d.style.display = 'none';
    c2d.style.display = 'block';
    btn.innerText = '查看 3D 預覽';
    if(debug) debug.style.display = 'none';
  }
}

function disposeObject(obj){
  if(!obj) return;
  if(obj.geometry) obj.geometry.dispose();
  if(obj.material){
    if(Array.isArray(obj.material)) obj.material.forEach(m => m && m.dispose && m.dispose());
    else if(obj.material.dispose) obj.material.dispose();
  }
}

function clearGroup(group){
  if(!group) return;
  for(let i = group.children.length - 1; i >= 0; i--){
    const child = group.children[i];
    child.traverse?.(n => { if(n.isMesh) disposeObject(n); });
    group.remove(child);
  }
}

function buildRoom3D(){
  clearGroup(roomGroup3D);

  const w = mmToPx(ROOM.widthMm);
  const d = mmToPx(ROOM.depthMm);
  const wallH = mmToPx(ROOM.wallHeightMm);
  const t = mmToPx(ROOM.wallThicknessMm);

  // 3D coordinates: x horizontal, z depth, y up.
  // Place room centered at (0,0,0) on ground y=0, walls from y=0..wallH

  const wallMat = new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 0.9, metalness: 0.0 });
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.95, metalness: 0.0 });

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(w, d), floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  roomGroup3D.add(floor);

  // 4 walls
  const wallGeo1 = new THREE.BoxGeometry(w, wallH, t);
  const wallGeo2 = new THREE.BoxGeometry(t, wallH, d);

  const wallN = new THREE.Mesh(wallGeo1, wallMat);
  wallN.position.set(0, wallH/2, -d/2);
  wallN.castShadow = true; wallN.receiveShadow = true;

  const wallS = new THREE.Mesh(wallGeo1, wallMat);
  wallS.position.set(0, wallH/2, d/2);

  const wallW = new THREE.Mesh(wallGeo2, wallMat);
  wallW.position.set(-w/2, wallH/2, 0);

  const wallE = new THREE.Mesh(wallGeo2, wallMat);
  wallE.position.set(w/2, wallH/2, 0);

  [wallN, wallS, wallW, wallE].forEach(wm => { wm.castShadow = true; wm.receiveShadow = true; roomGroup3D.add(wm); });
}

function update3D(){
  if(!sc) return;

  // rebuild room
  buildRoom3D();

  // clear objects
  clearGroup(objectsGroup);
  threeMap.clear();
  pickables.length = 0;

  const roomRect = getRoomRectPx();
  const roomWpx = mmToPx(ROOM.widthMm);
  const roomDpx = mmToPx(ROOM.depthMm);

  // Map 2D px into 3D coords:
  // room center -> 3D origin.
  // x3d = (x2d - roomCenterX) + w/2 offset correction by object center etc
  const roomCenterX = roomRect.x + roomRect.width/2;
  const roomCenterY = roomRect.y + roomRect.height/2;

  const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));

  groups.forEach(n => {
    const r = n.findOne('.main-rect');
    const wPx = r.width() * n.scaleX();
    const dPx = r.height() * n.scaleY();
    const hPx = n.attrs.customData?.height3dPx || mmToPx(800);

    const center2dX = n.x() + wPx/2;
    const center2dY = n.y() + dPx/2;

    const x3d = center2dX - roomCenterX;
    const z3d = center2dY - roomCenterY;

    const id = n._id;
    const key = n.attrs.customData?.deviceKey || n.name();

    if(n.name() === 'device'){
      const baseMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(r.fill()),
        roughness: 0.6,
        metalness: 0.05
      });
      const hiMat = baseMat.clone();
      hiMat.emissive = new THREE.Color(0x1d4ed8);
      hiMat.emissiveIntensity = 0.35;

      const mesh = new THREE.Mesh(new THREE.BoxGeometry(wPx, hPx, dPx), baseMat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { konvaId: id, kind: 'device' };

      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(mesh.geometry),
        new THREE.LineBasicMaterial({ color: 0x93c5fd, transparent: true, opacity: 0.95 })
      );
      edges.visible = false;

      const root = new THREE.Group();
      root.add(mesh); root.add(edges);

      root.position.set(x3d, hPx/2, z3d);
      root.rotation.y = -THREE.MathUtils.degToRad(n.rotation());

      objectsGroup.add(root);
      threeMap.set(id, { root, mesh, edges, baseMaterial: baseMat, highlightMaterial: hiMat, key });
      pickables.push(mesh);
    }else{
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x3b82f6,
        transparent: true,
        opacity: 0.18,
        roughness: 0.95,
        metalness: 0.0,
        side: THREE.DoubleSide
      });
      const hiMat = baseMat.clone();
      hiMat.opacity = 0.28;
      hiMat.emissive = new THREE.Color(0x1d4ed8);
      hiMat.emissiveIntensity = 0.18;

      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(wPx, dPx), baseMat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.set(x3d, 1, z3d);
      mesh.receiveShadow = true;
      mesh.userData = { konvaId: id, kind: 'zone' };

      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(mesh.geometry),
        new THREE.LineBasicMaterial({ color: 0x60a5fa, transparent: true, opacity: 0.9 })
      );
      edges.rotation.copy(mesh.rotation);
      edges.position.copy(mesh.position);
      edges.visible = false;

      const root = new THREE.Group();
      root.add(mesh); root.add(edges);

      objectsGroup.add(root);
      threeMap.set(id, { root, mesh, edges, baseMaterial: baseMat, highlightMaterial: hiMat, key: 'zone' });
      pickables.push(mesh);
    }
  });

  fitCameraToRoom(roomWpx, roomDpx);
  sync3DSelectionHighlight();
  updateDebug3D();
}

function sync3DSelectionHighlight(){
  if(!sc || !objectsGroup) return;
  const sel = new Set(selectedNodes.map(n => n._id));
  threeMap.forEach((obj, id) => {
    const selected = sel.has(id);
    obj.mesh.material = selected ? obj.highlightMaterial : obj.baseMaterial;
    obj.edges.visible = selected;
  });
}

function fitCameraToRoom(roomWpx, roomDpx){
  if(!cam || !ctrl) return;
  const maxDim = Math.max(roomWpx, roomDpx);
  const center = new THREE.Vector3(0, 0, 0);
  ctrl.target.copy(center);

  const fov = cam.fov * (Math.PI / 180);
  let dist = Math.abs(maxDim / 2 / Math.tan(fov / 2));
  dist *= 1.4;

  const dir = new THREE.Vector3(1, 1, 1).normalize();
  cam.position.copy(center.clone().add(dir.multiplyScalar(dist)));
  cam.near = Math.max(1, dist / 100);
  cam.far = Math.max(20000, dist * 10);
  cam.updateProjectionMatrix();
  ctrl.update();
}

function animate3D(){
  if(is3DVisible()){
    requestAnimationFrame(animate3D);
    ctrl.update();
    rend.render(sc, cam);
  }
}

function updateDebug3D(){
  const debug = document.getElementById('debug3d');
  if(!debug || !is3DVisible()) return;
  const { w, h } = get3DSize();
  debug.textContent =
    `3D: ${w} x ${h}\n` +
    `Room: ${ROOM.widthMm}x${ROOM.depthMm}mm\n` +
    `Objects: ${threeMap.size}\n` +
    `Selected: ${selectedNodes.length}\n`;
}

/* ===========================
 * 3D picking + info card
 * =========================== */
function onPointerDown3D(e){
  if(!is3DVisible()) return;
  if(!cam) return;

  const rect = rend.domElement.getBoundingClientRect();
  const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

  pointer.set(x, y);
  raycaster.setFromCamera(pointer, cam);

  const hits = raycaster.intersectObjects(pickables, false);
  if(hits.length === 0){
    hideInfoCard();
    // click empty clears selection unless shift held
    if(!e.shiftKey){
      clearSelection();
      layer.draw();
    }
    return;
  }

  const hit = hits[0].object;
  const konvaId = hit.userData?.konvaId;
  if(!konvaId) return;

  // find node in layer by _id
  const node = layer.getChildren().find(n => n instanceof Konva.Group && n._id === konvaId);
  if(!node) return;

  if(e.shiftKey) toggleSelectNode(node);
  else selectSingleNode(node);

  // ensure 2D reflects immediately
  layer.draw();

  // show card
  showInfoCardFor(node, { x: e.clientX, y: e.clientY });
}

function getNodeSizeMm(node){
  const r = node.findOne('.main-rect');
  const wPx = r.width() * node.scaleX();
  const dPx = r.height() * node.scaleY();
  const hPx = node.attrs.customData?.height3dPx || 0;
  return { wMm: pxToMm(wPx), dMm: pxToMm(dPx), hMm: pxToMm(hPx) };
}

function showInfoCardFor(node, pointerClient){
  const card = document.getElementById('info-card');
  if(!card) return;

  const name = node.findOne('.title-text')?.text() || '';
  const key = node.attrs.customData?.deviceKey || node.name();
  const size = getNodeSizeMm(node);

  card.innerHTML = `
    <div class="info-title">
      <div class="info-icon">⟲</div>
      <div style="flex:1;">
        <div style="font-weight:800;">${escapeHtml(name)}</div>
      </div>
    </div>
    <div class="info-row"><div class="info-key">類別</div><div>${escapeHtml(key)}</div></div>
    <div class="info-row"><div class="info-key">尺寸</div><div>${size.wMm}×${size.dMm}mm</div></div>
    <div class="info-row"><div class="info-key">擺放高度</div><div>${fmtCm(size.hMm)}</div></div>
  `;

  card.style.display = 'block';

  // position near pointer
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const cardRect = { w: 300, h: 140 };
  let left = pointerClient.x + 14;
  let top = pointerClient.y + 14;
  if(left + cardRect.w > vw) left = pointerClient.x - cardRect.w - 14;
  if(top + cardRect.h > vh) top = pointerClient.y - cardRect.h - 14;

  card.style.left = `${left}px`;
  card.style.top = `${top}px`;
}

function hideInfoCard(){
  const card = document.getElementById('info-card');
  if(card) card.style.display = 'none';
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (m) => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[m]));
}

/* ===========================
 * Hotkeys
 * =========================== */
window.addEventListener('keydown', (e) => {
  const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : '';
  const typing = tag === 'input' || tag === 'textarea';

  if(e.key === 'Escape'){
    hideInfoCard();
    clearSelection();
    layer.draw();
    sync3DSelectionHighlight();
    return;
  }

  if(!typing && (e.key === 'Delete' || e.key === 'Backspace')){
    deleteSelected();
    e.preventDefault();
    return;
  }

  if(!typing && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a'){
    const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));
    selectedNodes = groups;
    selectedNode = selectedNodes.length === 1 ? selectedNodes[0] : null;
    applyTransformer();
    renderInspector();
    e.preventDefault();
  }
});

/* ===========================
 * Resize
 * =========================== */
window.addEventListener('resize', () => {
  stage.width(window.innerWidth - 600);
  stage.height(window.innerHeight);

  drawGrid();
  drawRoomBoundary2D();
  layer.draw();

  if(is3DVisible()) resize3D();
});

/* ===========================
 * Boot
 * =========================== */
renderDeviceCatalog();
drawGrid();
drawRoomBoundary2D();
renderInspector();
tryLoadFromLocalStorage();
</script>
</body>
</html>
