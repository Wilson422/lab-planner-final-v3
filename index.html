<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LabCAD Web Pro - 實驗室規劃系統</title>

  <script src="https://unpkg.com/konva@9/konva.min.js"></script>

  <!-- Stable non-module three stack -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root{
      --bg-dark:#0f172a; --bg-sidebar:#1e293b; --primary:#3b82f6; --accent:#10b981; --danger:#ef4444; --border:#334155; --text:#f1f5f9;
      --warn:#f59e0b;
    }
    body{ margin:0; font-family:'Segoe UI',system-ui; background:var(--bg-dark); color:var(--text); overflow:hidden; }
    .app{ display:grid; grid-template-columns:280px 1fr 320px; height:100vh; }
    .sidebar{ background:var(--bg-sidebar); border-right:1px solid var(--border); display:flex; flex-direction:column; overflow:auto; }
    .sidebar-header{ padding:20px; background:#111827; font-weight:bold; border-bottom:1px solid var(--border); position:sticky; top:0; z-index:2; }
    .tool-section{ padding:15px; border-bottom:1px solid var(--border); }
    .tool-section-title{ font-size:12px; letter-spacing:.08em; color:#94a3b8; text-transform:uppercase; margin-bottom:10px; }
    .item{ background:#334155; padding:10px; border-radius:6px; cursor:pointer; text-align:center; font-size:.8rem; margin-bottom:8px; user-select:none; }
    .item:hover{ background:#475569; border:1px solid var(--primary); }

    .canvas-area{ position:relative; background:#f1f5f9; }
    #container,#three-container{ width:100%; height:100%; }
    #three-container{ position:absolute; top:0; left:0; display:none; z-index:60; background:#0a0f1a; }

    .toolbar{
      position:absolute; top:20px; left:50%; transform:translateX(-50%);
      background:rgba(30,41,59,.95); padding:8px 16px; border-radius:50px;
      display:flex; gap:12px; z-index:100; border:1px solid var(--border);
      align-items:center;
    }
    .tool-btn{ background:none; border:none; color:#cbd5e1; cursor:pointer; display:flex; align-items:center; }
    .tool-btn:hover{ color:#fff; }
    .tool-divider{ width:1px; height:18px; background:rgba(148,163,184,.35); margin:0 2px; }

    .inspector{ background:#1e293b; border-left:1px solid var(--border); padding:20px; color:#cbd5e1; overflow:auto; }
    .prop-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:15px; }
    .prop-group{ display:flex; flex-direction:column; gap:4px; }
    .prop-label{ font-size:.7rem; color:#94a3b8; text-transform:uppercase; }
    input{ background:#0f172a; border:1px solid #334155; color:#fff; padding:8px; border-radius:6px; font-size:.9rem; }

    .btn-action{
      color:#fff; border:none; padding:10px; border-radius:8px; cursor:pointer; font-weight:bold;
      width:100%; margin-top:12px; display:flex; align-items:center; justify-content:center; gap:5px;
    }

    #debug3d{
      position:absolute; right:10px; bottom:10px; z-index:200;
      background:rgba(15,23,42,.85); color:#e2e8f0; font-size:12px;
      padding:8px 10px; border:1px solid rgba(148,163,184,.35);
      border-radius:8px; display:none; white-space:pre;
    }

    #toast{
      position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(15,23,42,.9); color:#e2e8f0; font-size:13px;
      padding:8px 12px; border-radius:10px; border:1px solid rgba(148,163,184,.25);
      z-index:300; display:none;
    }

    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      background:rgba(148,163,184,.12);
      border:1px solid rgba(148,163,184,.25);
      color:#e2e8f0; font-size:12px;
      user-select:none;
    }
    .toggle{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px; border-radius:10px;
      border:1px solid rgba(148,163,184,.2);
      background:rgba(15,23,42,.35);
      margin-top:10px;
    }
    .toggle input{ width:auto; }
    .hint{ color:#94a3b8; font-size:12px; line-height:1.35; margin-top:10px; }

    #info-card{
      position:absolute;
      min-width: 240px;
      max-width: 340px;
      pointer-events:none;
      z-index: 250;
      display:none;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(96, 165, 250, 0.55);
      border-radius: 14px;
      padding: 12px 14px;
      color: #e2e8f0;
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .info-title{ font-weight:700; font-size:16px; margin-bottom:10px; display:flex; align-items:center; gap:10px; }
    .info-icon{
      width:34px; height:34px; border-radius:10px;
      background: rgba(59,130,246,0.18);
      border: 1px solid rgba(59,130,246,0.45);
      display:flex; align-items:center; justify-content:center;
      color:#93c5fd;
      font-weight:800;
    }
    .info-row{
      display:flex; justify-content:space-between; gap:14px;
      padding:6px 0;
      border-top: 1px solid rgba(148,163,184,0.16);
      font-size:13px;
    }
    .info-row:first-of-type{ border-top:none; }
    .info-key{ color:#94a3b8; }
  </style>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="sidebar-header">LabCAD Web Pro</div>

    <div class="tool-section">
      <div class="tool-section-title">房間</div>
      <div class="item" onclick="focusRoomSettings()">房間設定（寬/長/牆高）</div>
    </div>

    <div class="tool-section">
      <div class="tool-section-title">區域</div>
      <div class="item" onclick="addZone('新規劃區域')">新增區域</div>
    </div>

    <div class="tool-section" id="device-catalog">
      <div class="tool-section-title">設備</div>
      <div style="color:#94a3b8;font-size:12px;">載入中...</div>
    </div>

    <div style="margin-top:auto; padding:20px; position:sticky; bottom:0; background:linear-gradient(180deg, rgba(30,41,59,0), rgba(30,41,59,1) 30%);">
      <button class="btn-action" style="background:var(--accent);" id="toggle-3d" onclick="toggle3D()">查看 3D 預覽</button>
      <div class="hint" style="margin-top:10px;">
        單位：1格=10cm=100mm（格線10px）<br/>
        3D：點選物件可反選到2D（Shift可多選）<br/>
        7A：碰撞/走道警示（預設安全距離 100mm）
      </div>
    </div>
  </aside>

  <main class="canvas-area">
    <div class="toolbar" title="工具列">
      <button class="tool-btn" onclick="exportImg('png')" title="匯出 PNG"><i data-lucide="image"></i></button>
      <button class="tool-btn" onclick="exportImg('pdf')" title="匯出 PDF"><i data-lucide="file-text"></i></button>
      <button class="tool-btn" onclick="deleteSelected()" title="刪除選取"><i data-lucide="trash-2"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" onclick="exportDesignJSON()" title="匯出設計 JSON"><i data-lucide="download"></i></button>
      <button class="tool-btn" onclick="triggerImportJSON()" title="匯入設計 JSON"><i data-lucide="upload"></i></button>
      <input id="import-json-input" type="file" accept="application/json" style="display:none" />
      <button class="tool-btn" onclick="resetDesign(true)" title="重置 / 清空"><i data-lucide="rotate-ccw"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" onclick="toggleGrid()" title="顯示/隱藏格線"><i data-lucide="grid-3x3"></i></button>
      <button class="tool-btn" onclick="toggleSnap()" title="吸附格線"><i data-lucide="magnet"></i></button>
    </div>

    <div id="container"></div>
    <div id="three-container"></div>
    <div id="debug3d"></div>
    <div id="toast"></div>
    <div id="info-card"></div>
  </main>

  <aside class="inspector">
    <h3 id="ins-title">屬性</h3>
    <div id="inspector-content">請選擇物件</div>
  </aside>
</div>

<script>
/* ===========================
 * Boot UI icons
 * =========================== */
lucide.createIcons();

/* ===========================
 * Helpers
 * =========================== */
function toast(msg, ms=1200){
  const el=document.getElementById('toast');
  el.textContent=msg; el.style.display='block';
  clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none', ms);
}
function safeInt(v,f=0){ const n=parseInt(v,10); return Number.isFinite(n)?n:f; }
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* ===========================
 * Units
 * =========================== */
const GRID_PX=10;
const MM_PER_GRID=100;
const MM_PER_PX=MM_PER_GRID/GRID_PX;
function pxToMm(px){ return Math.round(px*MM_PER_PX); }
function mmToPx(mm){ return mm/MM_PER_PX; }
function mmToCm(mm){ return mm/10; }
function fmtMm(mm){ return `${Math.round(mm)}mm`; }
function fmtCm(mm){ return `${Math.round(mmToCm(mm))}cm`; }
function snapPx(v){ return Math.round(v/GRID_PX)*GRID_PX; }

/* ===========================
 * Room
 * =========================== */
const ROOM={ widthMm:6000, depthMm:4000, wallHeightMm:2800, wallThicknessMm:100 };

function focusRoomSettings(){
  selectedNodes=[]; selectedNode=null;
  tr.nodes([]);
  renderInspector('room');
  layer.draw();
  if(is3DVisible()) update3D();
}

/* ===========================
 * Device Catalog (mm)
 * =========================== */
const DEVICE_CATALOG=[
  { key:'bench', name:'實驗桌', wMm:1200, dMm:600,  hMm:800,  color:'#3b82f6' },
  { key:'hood',  name:'排煙櫃', wMm:1000, dMm:800,  hMm:2000, color:'#ef4444' },
  { key:'sink',  name:'洗滌槽', wMm:900,  dMm:600,  hMm:900,  color:'#22c55e' },
  { key:'fridge', name:'冰箱', wMm:700,  dMm:700,  hMm:1800, color:'#60a5fa' },
  { key:'centrifuge', name:'離心機', wMm:600, dMm:600, hMm:900, color:'#f59e0b' },
  { key:'ultra_low_freezer', name:'超低溫冰箱', wMm:800, dMm:800, hMm:2000, color:'#38bdf8' },
  { key:'incubator', name:'培養箱', wMm:700, dMm:600, hMm:1600, color:'#a78bfa' },
];
const DEVICE_BY_KEY=new Map(DEVICE_CATALOG.map(d=>[d.key,d]));

function renderDeviceCatalog(){
  const section=document.getElementById('device-catalog');
  const title=section.querySelector('.tool-section-title');
  section.innerHTML='';
  section.appendChild(title);
  DEVICE_CATALOG.forEach(d=>{
    const div=document.createElement('div');
    div.className='item';
    div.textContent=d.name;
    div.onclick=()=>addDeviceFromCatalog(d.key);
    section.appendChild(div);
  });
}
function addDeviceFromCatalog(key){
  const d=DEVICE_BY_KEY.get(key);
  if(!d) return;
  addDevice(d.name, mmToPx(d.wMm), mmToPx(d.dMm), mmToPx(d.hMm), d.color, d.key);
}

/* ===========================
 * 7A collision/clearance (2D)
 * =========================== */
const SAFETY_CLEARANCE_MM_DEFAULT=100;
let collisionPairs=[];
let conflictIds=new Set();
let collisionTimer=null;

function scheduleCollisionCheck(){
  clearTimeout(collisionTimer);
  collisionTimer=setTimeout(recomputeCollisions, 80);
}

function rectsOverlap(a,b){
  return !(a.x+a.width<=b.x || b.x+b.width<=a.x || a.y+a.height<=b.y || b.y+b.height<=a.y);
}
function expandRect(rect, mm){
  const px=mmToPx(mm);
  return { x:rect.x-px, y:rect.y-px, width:rect.width+px*2, height:rect.height+px*2 };
}
function getDeviceGroups(){
  return layer.getChildren().filter(n=>n instanceof Konva.Group && n.name()==='device');
}
function recomputeCollisions(){
  const devices=getDeviceGroups();
  collisionPairs=[];
  conflictIds=new Set();

  for(let i=0;i<devices.length;i++){
    for(let j=i+1;j<devices.length;j++){
      const A=devices[i], B=devices[j];
      const ra=A.getClientRect();
      const rb=B.getClientRect();

      if(rectsOverlap(ra, rb)){
        collisionPairs.push({ aId:A._id, bId:B._id, type:'overlap' });
        conflictIds.add(A._id); conflictIds.add(B._id);
        continue;
      }

      const ca=A.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT;
      const cb=B.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT;
      const c=Math.max(ca, cb);

      if(rectsOverlap(expandRect(ra,c), expandRect(rb,c))){
        collisionPairs.push({ aId:A._id, bId:B._id, type:'clearance' });
        conflictIds.add(A._id); conflictIds.add(B._id);
      }
    }
  }

  devices.forEach(updateUI);
  layer.draw();
  renderInspector();
  if(is3DVisible()) sync3DConflictHighlight();
}

/* ===========================
 * Konva 2D
 * =========================== */
const stage=new Konva.Stage({ container:'container', width:window.innerWidth-600, height:window.innerHeight });
const gridLayer=new Konva.Layer();
const layer=new Konva.Layer();
stage.add(gridLayer); stage.add(layer);

const tr=new Konva.Transformer({ keepRatio:false });
layer.add(tr);

let selectedNodes=[];
let selectedNode=null;

let gridVisible=true;
let snapEnabled=true;

function drawGrid(){
  gridLayer.destroyChildren();
  if(!gridVisible){ gridLayer.draw(); return; }
  const w=stage.width(), h=stage.height();
  for(let x=0;x<=w;x+=GRID_PX) gridLayer.add(new Konva.Line({ points:[x,0,x,h], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  for(let y=0;y<=h;y+=GRID_PX) gridLayer.add(new Konva.Line({ points:[0,y,w,y], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  gridLayer.draw();
}
function toggleGrid(){ gridVisible=!gridVisible; drawGrid(); scheduleAutosave(); }
function toggleSnap(){ snapEnabled=!snapEnabled; scheduleAutosave(); }

/* room boundary 2D */
let roomRect2D=null;
function drawRoomBoundary2D(){
  if(roomRect2D) roomRect2D.destroy();
  const wPx=mmToPx(ROOM.widthMm), dPx=mmToPx(ROOM.depthMm);
  roomRect2D=new Konva.Rect({
    x:snapPx((stage.width()-wPx)/2),
    y:snapPx((stage.height()-dPx)/2),
    width:wPx, height:dPx,
    stroke:'rgba(15,23,42,0.45)', strokeWidth:2,
    fill:'rgba(15,23,42,0.03)',
    listening:false
  });
  gridLayer.add(roomRect2D);
  gridLayer.draw();
}
function getRoomRectPx(){ if(!roomRect2D) drawRoomBoundary2D(); return roomRect2D.getClientRect(); }

/* selection rect */
let selecting=false;
let selectionRect=new Konva.Rect({ x:0,y:0,width:0,height:0, fill:'rgba(59,130,246,0.12)', stroke:'rgba(59,130,246,0.9)', strokeWidth:1, visible:false, listening:false });
layer.add(selectionRect);
let startPos=null;

/* CRUD */
function addZone(name){
  createNode('zone', name, mmToPx(3000), mmToPx(2000), 0, 'rgba(59,130,246,0.1)', '#3b82f6', 'zone');
}
function addDevice(name,wPx,dPx,hPx,color,deviceKey){
  createNode('device', name, wPx, dPx, hPx, color, '#1e293b', deviceKey||'device');
}
function createNode(type,name,wPx,dPx,hPx,fill,stroke,deviceKey){
  const group=new Konva.Group({
    x:100,y:100, draggable:true, name:type,
    customData:{ height3dPx:hPx||0, deviceKey, clearanceMm: SAFETY_CLEARANCE_MM_DEFAULT }
  });

  const rect=new Konva.Rect({ width:wPx, height:dPx, fill, stroke, name:'main-rect', dash: type==='zone' ? [10,5] : [] });
  const title=new Konva.Text({ text:name, fontSize:14, fill:stroke, padding:8, name:'title-text' });
  const dim=new Konva.Text({ text:'', fontSize:10, fill:stroke, name:'dim-label' });

  group.add(rect,title,dim);
  updateUI(group);

  group.on('dragmove',()=>{
    if(snapEnabled) group.position({ x:snapPx(group.x()), y:snapPx(group.y()) });
    constrainToRoom(group);
    updateUI(group);
    scheduleAutosave();
    scheduleCollisionCheck();
  });
  group.on('dragend',()=>{ scheduleAutosave(); scheduleCollisionCheck(); });
  group.on('transform',()=>{ updateUI(group); scheduleAutosave(); scheduleCollisionCheck(); });
  group.on('transformend',()=>{
    if(snapEnabled) normalizeGroupToGrid(group);
    constrainToRoom(group);
    scheduleAutosave();
    scheduleCollisionCheck();
    if(is3DVisible()) update3D();
  });

  group.on('click tap',(e)=>{
    e.cancelBubble=true;
    const multi=e.evt && e.evt.shiftKey;
    if(multi) toggleSelectNode(group); else selectSingleNode(group);
  });

  layer.add(group);
  if(type==='zone') group.moveToBottom();
  selectSingleNode(group);
  layer.draw();

  scheduleAutosave();
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();
}

function normalizeGroupToGrid(group){
  group.x(snapPx(group.x())); group.y(snapPx(group.y()));
  const rect=group.findOne('.main-rect');
  const absW=rect.width()*group.scaleX();
  const absH=rect.height()*group.scaleY();
  const targetW=Math.max(GRID_PX, snapPx(absW));
  const targetH=Math.max(GRID_PX, snapPx(absH));
  group.scaleX(targetW/rect.width());
  group.scaleY(targetH/rect.height());
}
function constrainToRoom(group){
  const rr=getRoomRectPx();
  const r=group.findOne('.main-rect');
  const w=r.width()*group.scaleX();
  const h=r.height()*group.scaleY();
  group.position({
    x: clamp(group.x(), rr.x, rr.x+rr.width-w),
    y: clamp(group.y(), rr.y, rr.y+rr.height-h)
  });
}

function updateUI(group){
  const rect=group.findOne('.main-rect');
  const dim=group.findOne('.dim-label');
  const wPx=rect.width()*group.scaleX();
  const dPx=rect.height()*group.scaleY();

  dim.text(`${fmtMm(pxToMm(wPx))} x ${fmtMm(pxToMm(dPx))}`);
  dim.x(rect.width()-dim.width()-5);
  dim.y(rect.height()-15);

  // 7A: collision stroke coloring for devices
  if(group.name()==='device'){
    if(conflictIds.has(group._id)){
      const hard = collisionPairs.some(p => p.type==='overlap' && (p.aId===group._id || p.bId===group._id));
      rect.stroke(hard ? '#ef4444' : '#f59e0b');
      rect.strokeWidth(2);
    }else{
      rect.stroke('#1e293b');
      rect.strokeWidth(1);
    }
  }

  if(selectedNodes.includes(group)) renderInspector();
}

/* selection model */
function applyTransformer(){ tr.nodes(selectedNodes); layer.draw(); sync3DSelectionHighlight(); if(is3DVisible()) sync3DConflictHighlight(); }
function clearSelection(){ selectedNodes=[]; selectedNode=null; applyTransformer(); renderInspector(); }
function selectSingleNode(node){ selectedNodes=[node]; selectedNode=node; applyTransformer(); renderInspector(); }
function toggleSelectNode(node){
  const idx=selectedNodes.indexOf(node);
  if(idx>=0) selectedNodes.splice(idx,1); else selectedNodes.push(node);
  selectedNode = selectedNodes.length===1 ? selectedNodes[0] : null;
  applyTransformer(); renderInspector();
}

/* click empty + marquee */
stage.on('click tap',(e)=>{ if(e.target===stage){ clearSelection(); if(is3DVisible()) update3D(); }});
stage.on('mousedown touchstart',(e)=>{
  if(is3DVisible()) return;
  if(e.target!==stage) return;
  selecting=true;
  startPos=stage.getPointerPosition();
  selectionRect.visible(true);
  selectionRect.position(startPos);
  selectionRect.size({width:0,height:0});
  layer.draw();
});
stage.on('mousemove touchmove',()=>{
  if(!selecting) return;
  const pos=stage.getPointerPosition(); if(!pos) return;
  const x=Math.min(startPos.x,pos.x);
  const y=Math.min(startPos.y,pos.y);
  const w=Math.abs(pos.x-startPos.x);
  const h=Math.abs(pos.y-startPos.y);
  selectionRect.setAttrs({x,y,width:w,height:h});
  layer.batchDraw();
});
stage.on('mouseup touchend',(e)=>{
  if(!selecting) return;
  selecting=false;
  selectionRect.visible(false);
  layer.draw();

  const box=selectionRect.getClientRect();
  const groups=layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'));
  const additive=e.evt && e.evt.shiftKey;
  const hits=groups.filter(g=>Konva.Util.haveIntersection(box, g.getClientRect()));
  if(!additive) selectedNodes=[];
  hits.forEach(g=>{ if(!selectedNodes.includes(g)) selectedNodes.push(g); });
  selectedNode = selectedNodes.length===1 ? selectedNodes[0] : null;
  applyTransformer(); renderInspector();
  if(is3DVisible()) update3D();
});

/* ===========================
 * Inspector
 * =========================== */
function renderInspector(mode){
  const c=document.getElementById('inspector-content');

  if(mode==='room'){
    c.innerHTML=`
      <div class="chip">矩形房間設定</div>
      <div class="prop-grid" style="margin-top:12px;">
        <div class="prop-group"><label class="prop-label">寬度 (mm)</label><input type="number" value="${ROOM.widthMm}" oninput="updateRoom('widthMm', this.value)"></div>
        <div class="prop-group"><label class="prop-label">長度 (mm)</label><input type="number" value="${ROOM.depthMm}" oninput="updateRoom('depthMm', this.value)"></div>
        <div class="prop-group"><label class="prop-label">牆高 (mm)</label><input type="number" value="${ROOM.wallHeightMm}" oninput="updateRoom('wallHeightMm', this.value)"></div>
        <div class="prop-group"><label class="prop-label">牆厚 (mm)</label><input type="number" value="${ROOM.wallThicknessMm}" disabled></div>
      </div>
      <div class="hint" style="margin-top:10px;">2D 顯示邊界並限制拖曳；3D 生成地板與四面牆。</div>
    `;
    return;
  }

  if(selectedNodes.length===0){
    c.innerHTML=`<div class="chip">請選擇物件</div><div class="hint">衝突：<b>${collisionPairs.length}</b> 組（紅=重疊；橘=距離不足）</div>`;
    return;
  }

  if(selectedNodes.length>1){
    c.innerHTML=`<div class="chip">已選取：${selectedNodes.length} 個物件</div><div class="hint">衝突：<b>${collisionPairs.length}</b> 組</div>
      <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除選取</button>`;
    return;
  }

  const n=selectedNodes[0];
  const r=n.findOne('.main-rect');
  const wPx=r.width()*n.scaleX();
  const dPx=r.height()*n.scaleY();
  const hPx=n.attrs.customData?.height3dPx||0;
  const key=n.attrs.customData?.deviceKey||n.name();
  const clearance=n.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT;

  c.innerHTML=`
    <div class="chip">已選取：1 個物件</div>
    <div class="hint" style="margin-top:10px;">
      類別：<b>${escapeHtml(key)}</b><br/>
      尺寸：<b>${fmtMm(pxToMm(wPx))}×${fmtMm(pxToMm(dPx))}</b><br/>
      高度：<b>${fmtCm(pxToMm(hPx))}</b>
    </div>
    <div class="prop-group" style="margin-top:12px;">
      <label class="prop-label">安全距離 (mm)</label>
      <input type="number" value="${clearance}" oninput="updateClearance(this.value)">
    </div>
    <div class="hint">衝突：<b>${collisionPairs.length}</b> 組</div>
    <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除物件</button>
  `;
}

function updateRoom(p,v){
  ROOM[p]=Math.max(1000, safeInt(v, ROOM[p]));
  drawGrid();
  drawRoomBoundary2D();
  scheduleAutosave();
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();
}

function updateClearance(v){
  if(selectedNodes.length!==1) return;
  selectedNodes[0].attrs.customData.clearanceMm = Math.max(0, safeInt(v, SAFETY_CLEARANCE_MM_DEFAULT));
  scheduleAutosave();
  scheduleCollisionCheck();
}

/* ===========================
 * Export / Delete
 * =========================== */
function deleteSelected(){
  if(selectedNodes.length===0) return;
  selectedNodes.forEach(n=>n.destroy());
  clearSelection();
  layer.draw();
  scheduleAutosave();
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();
}

function exportImg(format){
  tr.nodes([]);
  layer.draw();
  if(format==='png'){
    const a=document.createElement('a');
    a.download='lab.png';
    a.href=stage.toDataURL();
    a.click();
  }else{
    const doc=new jspdf.jsPDF('l','px',[stage.width(), stage.height()]);
    doc.addImage(stage.toDataURL(), 'PNG', 0,0, stage.width(), stage.height());
    doc.save('lab.pdf');
  }
}

/* ===========================
 * Save/Load JSON
 * =========================== */
const STORAGE_KEY='labcad_design_v1';
let autosaveTimer=null;

function scheduleAutosave(){
  clearTimeout(autosaveTimer);
  autosaveTimer=setTimeout(()=>{
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(getDesignJSON())); }
    catch(err){ console.error(err); toast('自動保存失敗'); }
  }, 150);
}

function serializeNode(group){
  const r=group.findOne('.main-rect');
  const title=group.findOne('.title-text');
  const wPx=r.width()*group.scaleX();
  const dPx=r.height()*group.scaleY();
  const hPx=group.attrs.customData?.height3dPx||0;

  return {
    type: group.name(),
    key: group.attrs.customData?.deviceKey || group.name(),
    name: title ? title.text() : '',
    xMm: pxToMm(group.x()),
    yMm: pxToMm(group.y()),
    wMm: pxToMm(wPx),
    dMm: pxToMm(dPx),
    rot: group.rotation(),
    fill: r.fill(),
    stroke: r.stroke(),
    dash: r.dash(),
    hMm: pxToMm(hPx),
    clearanceMm: group.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT
  };
}

function getDesignJSON(){
  const nodes=layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone')).map(serializeNode);
  return {
    version: 80,
    savedAt: new Date().toISOString(),
    units: { gridPx: GRID_PX, mmPerGrid: MM_PER_GRID },
    room: { ...ROOM },
    ui: { gridVisible, snapEnabled },
    safety: { defaultClearanceMm: SAFETY_CLEARANCE_MM_DEFAULT },
    nodes
  };
}

function downloadText(filename,text,mime='application/json'){
  const blob=new Blob([text],{type:mime});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download=filename;
  document.body.appendChild(a); a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
function exportDesignJSON(){ downloadText('labcad-design.json', JSON.stringify(getDesignJSON(), null, 2)); toast('已匯出 JSON'); }

function triggerImportJSON(){ document.getElementById('import-json-input').click(); }
document.getElementById('import-json-input').addEventListener('change',(e)=>{
  const file=e.target.files && e.target.files[0];
  if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{ loadDesignFromObject(JSON.parse(reader.result)); toast('已匯入 JSON'); }
    catch(err){ console.error(err); toast('匯入失敗'); }
    finally{ e.target.value=''; }
  };
  reader.readAsText(file);
});

function resetDesign(clearLS=false){
  layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone')).forEach(g=>g.destroy());
  selectionRect.visible(false);
  clearSelection();
  layer.draw();
  if(clearLS){ localStorage.removeItem(STORAGE_KEY); toast('已清空設計'); }
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();
}

function loadDesignFromObject(design){
  resetDesign(false);

  if(design?.room){
    ROOM.widthMm = design.room.widthMm ?? ROOM.widthMm;
    ROOM.depthMm = design.room.depthMm ?? ROOM.depthMm;
    ROOM.wallHeightMm = design.room.wallHeightMm ?? ROOM.wallHeightMm;
    ROOM.wallThicknessMm = design.room.wallThicknessMm ?? ROOM.wallThicknessMm;
  }
  if(design?.ui){
    gridVisible = design.ui.gridVisible ?? gridVisible;
    snapEnabled = design.ui.snapEnabled ?? snapEnabled;
  }

  (design?.nodes||[]).forEach(n=>{
    const type=n.type==='zone'?'zone':'device';
    const stroke=n.stroke || (type==='zone' ? '#3b82f6' : '#1e293b');
    const dash=Array.isArray(n.dash) ? n.dash : (type==='zone' ? [10,5] : []);
    const fill=n.fill || (type==='zone' ? 'rgba(59,130,246,0.1)' : '#3b82f6');

    const group=new Konva.Group({
      x: mmToPx(Number(n.xMm)||0),
      y: mmToPx(Number(n.yMm)||0),
      draggable:true,
      name:type,
      customData:{
        height3dPx: mmToPx(Number(n.hMm)||0),
        deviceKey: n.key || type,
        clearanceMm: Number(n.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT)
      }
    });

    const rect=new Konva.Rect({
      width: mmToPx(Math.max(100, Number(n.wMm)||1000)),
      height: mmToPx(Math.max(100, Number(n.dMm)||1000)),
      fill, stroke, name:'main-rect', dash
    });

    const title=new Konva.Text({ text:n.name||'', fontSize:14, fill:stroke, padding:8, name:'title-text' });
    const dim=new Konva.Text({ text:'', fontSize:10, fill:stroke, name:'dim-label' });

    group.rotation(Number(n.rot)||0);
    group.add(rect,title,dim);
    updateUI(group);

    group.on('dragmove',()=>{
      if(snapEnabled) group.position({ x:snapPx(group.x()), y:snapPx(group.y()) });
      constrainToRoom(group);
      updateUI(group);
      scheduleAutosave();
      scheduleCollisionCheck();
    });
    group.on('dragend',()=>{ scheduleAutosave(); scheduleCollisionCheck(); });
    group.on('transform',()=>{ updateUI(group); scheduleAutosave(); scheduleCollisionCheck(); });
    group.on('transformend',()=>{
      if(snapEnabled) normalizeGroupToGrid(group);
      constrainToRoom(group);
      scheduleAutosave();
      scheduleCollisionCheck();
      if(is3DVisible()) update3D();
    });
    group.on('click tap',(e)=>{
      e.cancelBubble=true;
      const multi=e.evt && e.evt.shiftKey;
      if(multi) toggleSelectNode(group); else selectSingleNode(group);
    });

    layer.add(group);
    if(type==='zone') group.moveToBottom();
  });

  drawGrid();
  drawRoomBoundary2D();
  layer.draw();
  scheduleAutosave();
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();
}

function tryLoadFromLocalStorage(){
  const raw=localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{ loadDesignFromObject(JSON.parse(raw)); toast('已從自動保存載入'); }
  catch(err){ console.warn(err); }
}

/* ===========================
 * 3D: rounded geometry (approx) + prefabs
 * =========================== */
/**
 * Simplified rounded box geometry using Shape + ExtrudeGeometry.
 * - No modules needed
 * - Looks rounded enough for your "near-real" style
 */
function createRoundedRectShape(w, h, r){
  const x = -w/2, y = -h/2;
  const shape = new THREE.Shape();
  const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
  shape.moveTo(x + rr, y);
  shape.lineTo(x + w - rr, y);
  shape.quadraticCurveTo(x + w, y, x + w, y + rr);
  shape.lineTo(x + w, y + h - rr);
  shape.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
  shape.lineTo(x + rr, y + h);
  shape.quadraticCurveTo(x, y + h, x, y + h - rr);
  shape.lineTo(x, y + rr);
  shape.quadraticCurveTo(x, y, x + rr, y);
  return shape;
}

function makeRoundedBox(w, h, d, radius, smoothSteps=4){
  // Build as extruded rounded rectangle along depth
  const shape = createRoundedRectShape(w, h, radius);
  const geo = new THREE.ExtrudeGeometry(shape, {
    depth: d,
    bevelEnabled: false,
    curveSegments: smoothSteps
  });
  // Center geometry: extrude goes +Z, so shift to center
  geo.translate(0, 0, -d/2);
  geo.computeVertexNormals();
  return geo;
}

function matStd(hex, opts={}){
  return new THREE.MeshStandardMaterial({
    color: new THREE.Color(hex),
    roughness: opts.roughness ?? 0.72,
    metalness: opts.metalness ?? 0.05,
    transparent: !!opts.transparent,
    opacity: opts.opacity ?? 1
  });
}

function matPanel(){
  const m = matStd('#0b1220', { roughness:0.5, metalness:0.05 });
  m.emissive = new THREE.Color(0x60a5fa);
  m.emissiveIntensity = 0.85;
  return m;
}

function addHandle(root, x, y, z, len){
  const geo = new THREE.CylinderGeometry(7,7,len,12);
  const mat = matStd('#cbd5e1', { roughness:0.28, metalness:0.75 });
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x,y,z);
  m.castShadow = true;
  root.add(m);
}

function addPanel(root, x, y, z, w, h){
  const geo = makeRoundedBox(w, h, 10, Math.min(8, w*0.08), 3);
  const m = new THREE.Mesh(geo, matPanel());
  m.position.set(x,y,z);
  m.castShadow = false;
  root.add(m);
}

function buildBench3D(w,d,h){
  const root = new THREE.Group();
  const topGeo = makeRoundedBox(w, 44, d, 16, 4);
  const top = new THREE.Mesh(topGeo, matStd('#f1f5f9', { roughness:0.88, metalness:0.02 }));
  top.position.set(0, h - 22, 0);
  top.castShadow = true; top.receiveShadow = true;
  root.add(top);

  const legH = h - 70;
  const legGeo = makeRoundedBox(28, legH, 28, 6, 2);
  const legMat = matStd('#334155', { roughness:0.92, metalness:0.08 });
  [[-w/2+26, legH/2, -d/2+26],[w/2-26, legH/2, -d/2+26],[-w/2+26, legH/2, d/2-26],[w/2-26, legH/2, d/2-26]]
    .forEach(([x,y,z])=>{
      const leg = new THREE.Mesh(legGeo, legMat);
      leg.position.set(x,y,z);
      leg.castShadow = true;
      root.add(leg);
    });

  return { root, pickHeight: h };
}

function buildCabinet3D(w,d,h,bodyHex,withGlass){
  const root = new THREE.Group();
  const radius = Math.min(22, Math.min(w,d)*0.08);

  const bodyGeo = makeRoundedBox(w, h, d, radius, 5);
  const body = new THREE.Mesh(bodyGeo, matStd(bodyHex, { roughness:0.78, metalness:0.05 }));
  body.position.set(0, h/2, 0);
  body.castShadow = true; body.receiveShadow = true;
  root.add(body);

  // door seam
  const seamGeo = makeRoundedBox(w*0.9, h*0.88, 2, Math.min(12, radius), 3);
  const seam = new THREE.Mesh(seamGeo, matStd('#0b1220', { roughness:1.0, metalness:0.0, transparent:true, opacity:0.55 }));
  seam.position.set(0, h/2, d/2 + 1);
  root.add(seam);

  // handle
  addHandle(root, w/2 - 36, h/2, d/2 + 14, h*0.45);

  // top panel
  addPanel(root, 0, h - 120, d/2 + 12, w*0.5, 74);

  if(withGlass){
    const glassGeo = makeRoundedBox(w*0.82, h*0.74, 8, Math.min(18, radius), 4);
    const glass = new THREE.Mesh(glassGeo, matStd('#93c5fd', { transparent:true, opacity:0.16, roughness:0.15, metalness:0.0 }));
    glass.position.set(0, h/2, d/2 + 8);
    glass.castShadow = false;
    root.add(glass);
  }

  return { root, pickHeight: h };
}

function buildCentrifuge3D(w,d,h){
  const root = new THREE.Group();
  const baseH = h*0.55;

  const baseGeo = makeRoundedBox(w, baseH, d, Math.min(18, Math.min(w,d)*0.08), 4);
  const base = new THREE.Mesh(baseGeo, matStd('#f1f5f9', { roughness:0.82 }));
  base.position.set(0, baseH/2, 0);
  base.castShadow = true; base.receiveShadow = true;
  root.add(base);

  const lid = new THREE.Mesh(
    new THREE.CylinderGeometry(Math.min(w,d)*0.38, Math.min(w,d)*0.38, h*0.28, 28),
    matStd('#cbd5e1', { roughness:0.55, metalness:0.08 })
  );
  lid.position.set(0, baseH + (h*0.14), 0);
  lid.castShadow = true;
  root.add(lid);

  addPanel(root, w*0.22, baseH*0.65, d/2 + 14, w*0.38, h*0.22);

  return { root, pickHeight: h };
}

function buildSink3D(w,d,h){
  const root = new THREE.Group();

  const topGeo = makeRoundedBox(w, 44, d, 16, 4);
  const top = new THREE.Mesh(topGeo, matStd('#f1f5f9', { roughness:0.9 }));
  top.position.set(0, h - 22, 0);
  top.castShadow = true; top.receiveShadow = true;
  root.add(top);

  const basinGeo = makeRoundedBox(w*0.55, 26, d*0.45, 14, 3);
  const basin = new THREE.Mesh(basinGeo, matStd('#cbd5e1', { roughness:0.4, metalness:0.28 }));
  basin.position.set(-w*0.08, h - 30, 0);
  root.add(basin);

  const post = new THREE.Mesh(
    new THREE.CylinderGeometry(10,10,120,14),
    matStd('#94a3b8', { roughness:0.3, metalness:0.75 })
  );
  post.position.set(w*0.2, h + 30, 0);
  post.castShadow = true;
  root.add(post);

  const spout = new THREE.Mesh(
    new THREE.CylinderGeometry(8,8,120,14),
    post.material
  );
  spout.rotation.z = Math.PI/2;
  spout.position.set(w*0.2 + 55, h + 70, 0);
  spout.castShadow = true;
  root.add(spout);

  const cabGeo = makeRoundedBox(w*0.92, h-60, d*0.92, 16, 4);
  const cab = new THREE.Mesh(cabGeo, matStd('#f8fafc', { roughness:0.9 }));
  cab.position.set(0, (h-60)/2, 0);
  cab.castShadow = true;
  root.add(cab);

  addHandle(root, w*0.35, (h-60)/2, d/2 + 14, (h-60)*0.35);

  return { root, pickHeight: h };
}

function buildHood3D(w,d,h){
  const root = new THREE.Group();
  const radius = Math.min(22, Math.min(w,d)*0.08);

  const bodyGeo = makeRoundedBox(w, h, d, radius, 5);
  const body = new THREE.Mesh(bodyGeo, matStd('#f1f5f9', { roughness:0.9 }));
  body.position.set(0, h/2, 0);
  body.castShadow = true; body.receiveShadow = true;
  root.add(body);

  const glassGeo = makeRoundedBox(w*0.9, h*0.55, 10, Math.min(16, radius), 4);
  const glass = new THREE.Mesh(glassGeo, matStd('#93c5fd', { transparent:true, opacity:0.18, roughness:0.12, metalness:0.0 }));
  glass.position.set(0, h*0.55, d/2 + 12);
  glass.castShadow = false;
  root.add(glass);

  addPanel(root, 0, h - 140, d/2 + 16, w*0.6, 84);

  const baseGeo = makeRoundedBox(w, 46, d, 14, 3);
  const base = new THREE.Mesh(baseGeo, matStd('#94a3b8', { roughness:0.95, metalness:0.05 }));
  base.position.set(0, 23, 0);
  base.castShadow = true;
  root.add(base);

  return { root, pickHeight: h };
}

function buildPrefab3D(key,w,d,h){
  switch(key){
    case 'bench': return buildBench3D(w,d,mmToPx(800));
    case 'fridge': return buildCabinet3D(w,d,h,'#f8fafc',false);
    case 'ultra_low_freezer': return buildCabinet3D(w,d,h,'#e2e8f0',false);
    case 'incubator': return buildCabinet3D(w,d,h,'#f8fafc',true);
    case 'centrifuge': return buildCentrifuge3D(w,d,h);
    case 'sink': return buildSink3D(w,d,mmToPx(900));
    case 'hood': return buildHood3D(w,d,h);
    default: return buildCabinet3D(w,d,h,'#e5e7eb',false);
  }
}

/* ===========================
 * 3D Engine (non-module)
 * =========================== */
let sc, cam, rend, ctrl;
let objectsGroup, roomGroup3D, groundMesh, dirLight;

const threeMap=new Map();
const pickables=[];
const raycaster=new THREE.Raycaster();
const pointer=new THREE.Vector2();

function is3DVisible(){
  const c3d=document.getElementById('three-container');
  return c3d && c3d.style.display==='block';
}
function get3DSize(){
  const c3d=document.getElementById('three-container');
  return { w:Math.max(1,c3d.clientWidth||0), h:Math.max(1,c3d.clientHeight||0) };
}
function resize3D(){
  if(!rend||!cam) return;
  const {w,h}=get3DSize();
  rend.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  rend.setSize(w,h,false);
  cam.aspect=w/h;
  cam.updateProjectionMatrix();
  updateDebug3D();
}
function init3DIfNeeded(){
  const c3d=document.getElementById('three-container');
  if(sc) return;

  sc=new THREE.Scene();
  sc.background=new THREE.Color(0x0a0f1a);

  const {w,h}=get3DSize();
  cam=new THREE.PerspectiveCamera(45,w/h,1,20000);
  cam.position.set(1000,1000,1000);

  rend=new THREE.WebGLRenderer({ antialias:true, alpha:false });
  rend.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  rend.setSize(w,h,false);
  rend.shadowMap.enabled=true;
  rend.shadowMap.type=THREE.PCFSoftShadowMap;
  c3d.appendChild(rend.domElement);

  ctrl=new THREE.OrbitControls(cam, rend.domElement);
  ctrl.enableDamping=true;
  ctrl.dampingFactor=0.08;
  ctrl.target.set(0,0,0);
  ctrl.update();

  sc.add(new THREE.AmbientLight(0xffffff,0.55));

  dirLight=new THREE.DirectionalLight(0xffffff,0.9);
  dirLight.position.set(1200,1800,900);
  dirLight.castShadow=true;
  dirLight.shadow.mapSize.width=2048;
  dirLight.shadow.mapSize.height=2048;
  dirLight.shadow.camera.near=1;
  dirLight.shadow.camera.far=12000;
  dirLight.shadow.camera.left=-5000;
  dirLight.shadow.camera.right=5000;
  dirLight.shadow.camera.top=5000;
  dirLight.shadow.camera.bottom=-5000;
  sc.add(dirLight);

  const groundGeo=new THREE.PlaneGeometry(12000,12000);
  const groundMat=new THREE.MeshStandardMaterial({ color:0x0b1220, roughness:0.95, metalness:0.0 });
  groundMesh=new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x=-Math.PI/2;
  groundMesh.position.y=0;
  groundMesh.receiveShadow=true;
  sc.add(groundMesh);

  sc.add(new THREE.GridHelper(8000,80,0x334155,0x1e293b));

  roomGroup3D=new THREE.Group();
  sc.add(roomGroup3D);

  objectsGroup=new THREE.Group();
  sc.add(objectsGroup);

  rend.domElement.addEventListener('pointerdown', onPointerDown3D);
}

function buildRoom3D(){
  while(roomGroup3D.children.length) roomGroup3D.remove(roomGroup3D.children[0]);
  const w=mmToPx(ROOM.widthMm), d=mmToPx(ROOM.depthMm);
  const wallH=mmToPx(ROOM.wallHeightMm), t=mmToPx(ROOM.wallThicknessMm);

  const wallMat=new THREE.MeshStandardMaterial({ color:0x111827, roughness:0.9, metalness:0.0 });
  const floorMat=new THREE.MeshStandardMaterial({ color:0x0b1220, roughness:0.95, metalness:0.0 });

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(w,d), floorMat);
  floor.rotation.x=-Math.PI/2;
  floor.receiveShadow=true;
  roomGroup3D.add(floor);

  const wallGeo1=new THREE.BoxGeometry(w,wallH,t);
  const wallGeo2=new THREE.BoxGeometry(t,wallH,d);

  const wallN=new THREE.Mesh(wallGeo1, wallMat); wallN.position.set(0,wallH/2,-d/2);
  const wallS=new THREE.Mesh(wallGeo1, wallMat); wallS.position.set(0,wallH/2,d/2);
  const wallW=new THREE.Mesh(wallGeo2, wallMat); wallW.position.set(-w/2,wallH/2,0);
  const wallE=new THREE.Mesh(wallGeo2, wallMat); wallE.position.set(w/2,wallH/2,0);

  [wallN,wallS,wallW,wallE].forEach(wm=>{ wm.castShadow=true; wm.receiveShadow=true; roomGroup3D.add(wm); });
}

function update3D(){
  if(!sc) return;

  buildRoom3D();

  while(objectsGroup.children.length) objectsGroup.remove(objectsGroup.children[0]);
  threeMap.clear();
  pickables.length=0;

  const rr=getRoomRectPx();
  const cx=rr.x+rr.width/2;
  const cy=rr.y+rr.height/2;

  const groups=layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'));

  groups.forEach(n=>{
    const r=n.findOne('.main-rect');
    const wPx=r.width()*n.scaleX();
    const dPx=r.height()*n.scaleY();
    const hPx=n.attrs.customData?.height3dPx || mmToPx(800);

    const x3d=(n.x()+wPx/2)-cx;
    const z3d=(n.y()+dPx/2)-cy;

    const id=n._id;
    const key=n.attrs.customData?.deviceKey || n.name();

    if(n.name()==='device'){
      const prefab=buildPrefab3D(key,wPx,dPx,hPx);
      const root=prefab.root;
      root.position.set(x3d,0,z3d);
      root.rotation.y = -THREE.MathUtils.degToRad(n.rotation());
      root.traverse(obj=>{ if(obj.isMesh){ obj.castShadow=true; obj.receiveShadow=true; }});

      // pick volume
      const pickGeo=new THREE.BoxGeometry(wPx, prefab.pickHeight || hPx, dPx);
      const pickMesh=new THREE.Mesh(pickGeo, new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0 }));
      pickMesh.position.set(0,(prefab.pickHeight||hPx)/2,0);
      pickMesh.userData={ konvaId:id, kind:'device' };
      root.add(pickMesh);

      // outline
      const outline=new THREE.LineSegments(new THREE.EdgesGeometry(pickGeo), new THREE.LineBasicMaterial({ color:0x93c5fd, transparent:true, opacity:0.95 }));
      outline.position.copy(pickMesh.position);
      outline.visible=false;
      root.add(outline);

      objectsGroup.add(root);
      threeMap.set(id,{ root, pickMesh, outline, key });
      pickables.push(pickMesh);
    }else{
      const mat=new THREE.MeshStandardMaterial({ color:0x3b82f6, transparent:true, opacity:0.18, roughness:0.95, metalness:0.0, side:THREE.DoubleSide });
      const mesh=new THREE.Mesh(new THREE.PlaneGeometry(wPx,dPx), mat);
      mesh.rotation.x=-Math.PI/2;
      mesh.position.set(x3d,1,z3d);
      mesh.userData={ konvaId:id, kind:'zone' };

      const edges=new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), new THREE.LineBasicMaterial({ color:0x60a5fa, transparent:true, opacity:0.9 }));
      edges.rotation.copy(mesh.rotation);
      edges.position.copy(mesh.position);
      edges.visible=false;

      const root=new THREE.Group();
      root.add(mesh); root.add(edges);
      objectsGroup.add(root);

      threeMap.set(id,{ root, pickMesh:mesh, outline:edges, key:'zone', zoneMesh:mesh });
      pickables.push(mesh);
    }
  });

  fitCameraToRoom();
  sync3DSelectionHighlight();
  sync3DConflictHighlight();
  updateDebug3D();
}

function fitCameraToRoom(){
  if(!cam||!ctrl) return;
  const maxDim=Math.max(mmToPx(ROOM.widthMm), mmToPx(ROOM.depthMm));
  ctrl.target.set(0,0,0);
  const fov=cam.fov*(Math.PI/180);
  let dist=Math.abs(maxDim/2/Math.tan(fov/2));
  dist*=1.35;
  const dir=new THREE.Vector3(1,1,1).normalize();
  cam.position.copy(dir.multiplyScalar(dist));
  cam.near=Math.max(1, dist/100);
  cam.far=Math.max(20000, dist*10);
  cam.updateProjectionMatrix();
  ctrl.update();
}

function sync3DSelectionHighlight(){
  const sel=new Set(selectedNodes.map(n=>n._id));
  threeMap.forEach((obj,id)=>{
    if(obj.zoneMesh){
      obj.zoneMesh.material.opacity = sel.has(id) ? 0.28 : 0.18;
      obj.outline.visible = sel.has(id);
      return;
    }
    obj.outline.visible = sel.has(id);
  });
}

function sync3DConflictHighlight(){
  threeMap.forEach((obj,id)=>{
    if(obj.zoneMesh) return;
    const isConflict=conflictIds.has(id);
    if(!obj.outline) return;
    if(!isConflict){
      obj.outline.material.color.setHex(0x93c5fd);
      return;
    }
    const hard = collisionPairs.some(p=>p.type==='overlap' && (p.aId===id || p.bId===id));
    obj.outline.material.color.setHex(hard ? 0xef4444 : 0xf59e0b);
    obj.outline.visible = true;
  });
}

function animate3D(){
  if(is3DVisible()){
    requestAnimationFrame(animate3D);
    ctrl.update();
    rend.render(sc, cam);
  }
}

function updateDebug3D(){
  const el=document.getElementById('debug3d');
  if(!el || !is3DVisible()) return;
  const {w,h}=get3DSize();
  el.textContent=`3D: ${w}x${h}\nObjects: ${threeMap.size}\nConflicts: ${collisionPairs.length}\n`;
}

/* picking + info card */
function onPointerDown3D(e){
  if(!is3DVisible() || !cam) return;
  const rect=rend.domElement.getBoundingClientRect();
  pointer.set(
    ((e.clientX-rect.left)/rect.width)*2-1,
    -(((e.clientY-rect.top)/rect.height)*2-1)
  );
  raycaster.setFromCamera(pointer, cam);

  const hits=raycaster.intersectObjects(pickables,false);
  if(hits.length===0){
    hideInfoCard();
    if(!e.shiftKey){ clearSelection(); layer.draw(); }
    return;
  }

  const id=hits[0].object.userData?.konvaId;
  const node=layer.getChildren().find(n=>n instanceof Konva.Group && n._id===id);
  if(!node) return;

  if(e.shiftKey) toggleSelectNode(node);
  else selectSingleNode(node);

  layer.draw();
  showInfoCardFor(node, { x:e.clientX, y:e.clientY });
}

function getNodeSizeMm(node){
  const r=node.findOne('.main-rect');
  const wPx=r.width()*node.scaleX();
  const dPx=r.height()*node.scaleY();
  const hPx=node.attrs.customData?.height3dPx||0;
  return { wMm:pxToMm(wPx), dMm:pxToMm(dPx), hMm:pxToMm(hPx) };
}

function showInfoCardFor(node, pt){
  const card=document.getElementById('info-card');
  const name=node.findOne('.title-text')?.text()||'';
  const key=node.attrs.customData?.deviceKey || node.name();
  const size=getNodeSizeMm(node);

  card.innerHTML=`
    <div class="info-title"><div class="info-icon">⟲</div><div style="flex:1;"><div style="font-weight:800;">${escapeHtml(name)}</div></div></div>
    <div class="info-row"><div class="info-key">類別</div><div>${escapeHtml(key)}</div></div>
    <div class="info-row"><div class="info-key">尺寸</div><div>${size.wMm}×${size.dMm}mm</div></div>
    <div class="info-row"><div class="info-key">擺放高度</div><div>${fmtCm(size.hMm)}</div></div>
  `;
  card.style.display='block';

  const vw=window.innerWidth, vh=window.innerHeight;
  const cw=320, ch=150;
  let left=pt.x+14, top=pt.y+14;
  if(left+cw>vw) left=pt.x-cw-14;
  if(top+ch>vh) top=pt.y-ch-14;
  card.style.left=`${left}px`;
  card.style.top=`${top}px`;
}

function hideInfoCard(){
  const card=document.getElementById('info-card');
  if(card) card.style.display='none';
}

/* toggle 3D */
function toggle3D(){
  const btn=document.getElementById('toggle-3d');
  const c2d=document.getElementById('container');
  const c3d=document.getElementById('three-container');
  const debug=document.getElementById('debug3d');

  const opening = (c3d.style.display==='' || c3d.style.display==='none');
  if(opening){
    c3d.style.display='block';
    c2d.style.display='none';
    debug.style.display='block';
    btn.innerText='返回 2D';
    requestAnimationFrame(()=>{
      init3DIfNeeded();
      resize3D();
      update3D();
      animate3D();
    });
  }else{
    hideInfoCard();
    c3d.style.display='none';
    c2d.style.display='block';
    debug.style.display='none';
    btn.innerText='查看 3D 預覽';
  }
}

/* hotkeys */
window.addEventListener('keydown',(e)=>{
  const tag=document.activeElement?.tagName?.toLowerCase();
  const typing = tag==='input' || tag==='textarea';

  if(e.key==='Escape'){
    hideInfoCard();
    clearSelection();
    layer.draw();
    sync3DSelectionHighlight();
    return;
  }
  if(!typing && (e.key==='Delete' || e.key==='Backspace')){
    deleteSelected();
    e.preventDefault();
    return;
  }
});

/* resize */
window.addEventListener('resize',()=>{
  stage.width(window.innerWidth-600);
  stage.height(window.innerHeight);
  drawGrid();
  drawRoomBoundary2D();
  layer.draw();
  if(is3DVisible()) resize3D();
});

/* init */
renderDeviceCatalog();
drawGrid();
drawRoomBoundary2D();
renderInspector();
tryLoadFromLocalStorage();
scheduleCollisionCheck();
</script>
</body>
</html>
