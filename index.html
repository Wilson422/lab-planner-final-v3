<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LabCAD Web Pro - å¯¦é©—å®¤è¦åŠƒç³»çµ±</title>

  <script src="https://unpkg.com/konva@9/konva.min.js"></script>

  <!-- Stable non-module three stack -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root{
      --bg-dark:#0f172a; --bg-sidebar:#111827; --sidebar2:#0b1220;
      --primary:#3b82f6; --accent:#10b981; --danger:#ef4444; --border:#263244; --text:#f1f5f9;
      --warn:#f59e0b;
    }
    body{ margin:0; font-family: ui-sans-serif,system-ui,'Segoe UI'; background:var(--bg-dark); color:var(--text); overflow:hidden; }
    .app{ display:grid; grid-template-columns:320px 1fr 320px; height:100vh; }

    /* sidebar */
    .sidebar{ background:linear-gradient(180deg,var(--bg-sidebar),var(--sidebar2)); border-right:1px solid var(--border); display:flex; flex-direction:column; overflow:hidden; }
    .sidebar-header{ padding:16px 16px 10px; background:rgba(17,24,39,.9); font-weight:800; border-bottom:1px solid rgba(148,163,184,.12); }
    .library-title{ font-size:14px; letter-spacing:.06em; color:#e2e8f0; }
    .tabs{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; padding:10px 16px 0; }
    .tab{
      text-align:center; padding:10px 0; border-radius:10px 10px 0 0;
      background:rgba(148,163,184,.06); color:#94a3b8; cursor:pointer; user-select:none;
      border:1px solid rgba(148,163,184,.12); border-bottom:none;
    }
    .tab.active{ background:rgba(30,41,59,.85); color:#38bdf8; border-color:rgba(56,189,248,.35); }
    .tab-panel{
      flex:1; overflow:auto;
      margin:0 16px 16px;
      border:1px solid rgba(148,163,184,.12);
      border-top:none;
      border-radius:0 12px 12px 12px;
      background:rgba(15,23,42,.45);
    }
    .panel-inner{ padding:12px; }
    .group-title{
      display:flex; align-items:center; justify-content:space-between;
      color:#cbd5e1; font-size:13px; font-weight:700;
      padding:10px 10px; border-radius:10px;
      cursor:pointer; user-select:none;
    }
    .group-title:hover{ background:rgba(148,163,184,.06); }
    .group-items{ padding:0 0 8px; }
    .lib-item{
      display:grid; grid-template-columns:26px 1fr; gap:10px;
      padding:10px 10px; border-radius:10px;
      background:rgba(148,163,184,.06);
      border:1px solid rgba(148,163,184,.12);
      margin-top:8px;
      cursor:pointer;
    }
    .lib-item:hover{ border-color:rgba(56,189,248,.5); background:rgba(56,189,248,.08); }
    .lib-icon{
      width:26px; height:26px; display:flex; align-items:center; justify-content:center;
      border-radius:8px; background:rgba(59,130,246,.14); color:#93c5fd;
    }
    .lib-name{ font-weight:800; color:#e2e8f0; font-size:14px; line-height:1.1; }
    .lib-sub{ font-size:12px; color:#94a3b8; margin-top:2px; }
    .hint{
      color:#94a3b8; font-size:12px; line-height:1.35; margin-top:12px;
      padding:10px; border:1px dashed rgba(148,163,184,.18); border-radius:12px;
      background:rgba(2,6,23,.25);
    }
    .mode-pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px; border-radius:999px;
      border:1px solid rgba(56,189,248,.35);
      color:#7dd3fc; background:rgba(56,189,248,.10);
      font-size:12px; font-weight:700;
    }

    /* canvas + inspector */
    .canvas-area{ position:relative; background:#f1f5f9; }
    #container,#three-container{ width:100%; height:100%; }
    #three-container{ position:absolute; top:0; left:0; display:none; z-index:60; background:#0a0f1a; }

    .toolbar{
      position:absolute; top:16px; left:50%; transform:translateX(-50%);
      background:rgba(15,23,42,.88); padding:8px 14px; border-radius:999px;
      display:flex; gap:12px; z-index:100; border:1px solid rgba(148,163,184,.18);
      align-items:center;
    }
    .tool-btn{ background:none; border:none; color:#cbd5e1; cursor:pointer; display:flex; align-items:center; }
    .tool-btn:hover{ color:#fff; }
    .tool-divider{ width:1px; height:18px; background:rgba(148,163,184,.25); margin:0 2px; }

    .inspector{ background:#0b1220; border-left:1px solid var(--border); padding:18px; color:#cbd5e1; overflow:auto; }
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      background:rgba(148,163,184,.10);
      border:1px solid rgba(148,163,184,.18);
      color:#e2e8f0; font-size:12px; user-select:none;
    }
    .prop-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:14px; }
    .prop-group{ display:flex; flex-direction:column; gap:4px; }
    .prop-label{ font-size:.7rem; color:#94a3b8; text-transform:uppercase; }
    input{ background:#020617; border:1px solid rgba(148,163,184,.22); color:#fff; padding:8px; border-radius:10px; font-size:.9rem; }
    .btn-action{
      color:#fff; border:none; padding:10px; border-radius:10px; cursor:pointer; font-weight:800;
      width:100%; margin-top:12px; display:flex; align-items:center; justify-content:center; gap:6px;
    }
    #debug3d{
      position:absolute; right:10px; bottom:10px; z-index:200;
      background:rgba(15,23,42,.85); color:#e2e8f0; font-size:12px;
      padding:8px 10px; border:1px solid rgba(148,163,184,.25);
      border-radius:10px; display:none; white-space:pre;
    }
    #toast{
      position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(15,23,42,.9); color:#e2e8f0; font-size:13px;
      padding:8px 12px; border-radius:12px; border:1px solid rgba(148,163,184,.18);
      z-index:300; display:none;
    }
    #info-card{
      position:absolute;
      min-width: 240px;
      max-width: 340px;
      pointer-events:none;
      z-index: 250;
      display:none;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(96, 165, 250, 0.55);
      border-radius: 14px;
      padding: 12px 14px;
      color: #e2e8f0;
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .info-title{ font-weight:800; font-size:16px; margin-bottom:10px; display:flex; align-items:center; gap:10px; }
    .info-icon{
      width:34px; height:34px; border-radius:10px;
      background: rgba(59,130,246,0.18);
      border: 1px solid rgba(59,130,246,0.45);
      display:flex; align-items:center; justify-content:center;
      color:#93c5fd;
      font-weight:900;
    }
    .info-row{
      display:flex; justify-content:space-between; gap:14px;
      padding:6px 0;
      border-top: 1px solid rgba(148,163,184,0.16);
      font-size:13px;
    }
    .info-row:first-of-type{ border-top:none; }
    .info-key{ color:#94a3b8; }
  </style>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="sidebar-header">
      <div class="library-title">å…ƒä»¶åº«</div>
      <div id="placement-pill" style="margin-top:10px; display:none;">
        <span class="mode-pill">æ”¾ç½®æ¨¡å¼ï¼š<span id="placement-name"></span>ï¼ˆé»ç•«å¸ƒæ”¾ç½® / Esc å–æ¶ˆï¼‰</span>
      </div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="devices">è¨­å‚™</div>
      <div class="tab" data-tab="zones">å€åŸŸ</div>
      <div class="tab" data-tab="walls">ç‰†å£</div>
    </div>

    <div class="tab-panel">
      <div class="panel-inner">
        <!-- DEVICES -->
        <div id="tab-devices">
          <div class="group-title" data-collapse="grp-instruments">
            <div>ğŸ”¬ å„€å™¨è¨­å‚™</div><div style="color:#64748b">â–¾</div>
          </div>
          <div class="group-items" id="grp-instruments"></div>

          <div class="group-title" data-collapse="grp-furniture">
            <div>ğŸª‘ å®¶å…·è¨­æ–½</div><div style="color:#64748b">â–¾</div>
          </div>
          <div class="group-items" id="grp-furniture"></div>

          <div class="hint">
            ç›´æ¥é»æ“Šæ¸…å–®æ–°å¢è¨­å‚™ï¼Œæ‹–æ›³èª¿æ•´ä½ç½®ã€‚<br/>
            Shiftï¼šå¤šé¸ / Deleteï¼šåˆªé™¤ã€‚
          </div>
        </div>

        <!-- ZONES -->
        <div id="tab-zones" style="display:none;">
          <div class="lib-item" data-action="place-zone" data-icon="square" data-name="è¦åŠƒå€åŸŸ" data-sub="3000Ã—2000mmï¼ˆå¯ç¸®æ”¾ï¼‰">
            <div class="lib-icon">â¬š</div>
            <div>
              <div class="lib-name">æ–°å¢å€åŸŸ</div>
              <div class="lib-sub">3000Ã—2000mmï¼ˆå¯ç¸®æ”¾ï¼‰</div>
            </div>
          </div>
          <div class="hint">
            é»ã€Œæ–°å¢å€åŸŸã€å¾Œï¼Œåœ¨ç•«å¸ƒé»ä¸€ä¸‹æ”¾ç½®ã€‚<br/>
            å€åŸŸå¯ç¸®æ”¾ã€å¯æ¡†é¸å¤šå€‹è¨­å‚™ã€‚
          </div>
        </div>

        <!-- WALLS -->
        <div id="tab-walls" style="display:none;">
          <div id="wall-items"></div>
          <div class="hint">
            é»é¸ç‰†å£é¡å‹å¾Œï¼Œåœ¨ç•«å¸ƒä¸Šé»æ“Šæ”¾ç½®ã€‚<br/>
            è¨­å‚™é è¿‘ç‰†é‚Šæœƒè‡ªå‹•è²¼é½Šï¼ˆå¸é™„ï¼‰ã€‚
          </div>
        </div>
      </div>
    </div>

    <div style="padding:16px; border-top:1px solid rgba(148,163,184,.12);">
      <button class="btn-action" style="background:var(--accent);" id="toggle-3d">æŸ¥çœ‹ 3D é è¦½</button>
      <div class="hint" style="margin-top:10px;">
        å–®ä½ï¼š1æ ¼=10cm=100mmï¼ˆæ ¼ç·š10pxï¼‰<br/>
        3Dï¼šé»é¸ç‰©ä»¶å¯åé¸åˆ°2Dï¼ˆShiftå¯å¤šé¸ï¼‰<br/>
        7A v2ï¼šæ©˜è‰²è·é›¢ä¸è¶³é¡¯ç¤ºè·é›¢ç·š+mm
      </div>
    </div>
  </aside>

  <main class="canvas-area">
    <div class="toolbar">
      <button class="tool-btn" id="btn-export-png" title="åŒ¯å‡º PNG"><i data-lucide="image"></i></button>
      <button class="tool-btn" id="btn-export-pdf" title="åŒ¯å‡º PDF"><i data-lucide="file-text"></i></button>
      <button class="tool-btn" id="btn-delete" title="åˆªé™¤é¸å–"><i data-lucide="trash-2"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" id="btn-export-json" title="åŒ¯å‡ºè¨­è¨ˆ JSON"><i data-lucide="download"></i></button>
      <button class="tool-btn" id="btn-import-json" title="åŒ¯å…¥è¨­è¨ˆ JSON"><i data-lucide="upload"></i></button>
      <input id="import-json-input" type="file" accept="application/json" style="display:none" />
      <button class="tool-btn" id="btn-reset" title="é‡ç½® / æ¸…ç©º"><i data-lucide="rotate-ccw"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" id="btn-grid" title="é¡¯ç¤º/éš±è—æ ¼ç·š"><i data-lucide="grid-3x3"></i></button>
      <button class="tool-btn" id="btn-snap" title="å¸é™„æ ¼ç·š"><i data-lucide="magnet"></i></button>
    </div>

    <div id="container"></div>
    <div id="three-container"></div>
    <div id="debug3d"></div>
    <div id="toast"></div>
    <div id="info-card"></div>
  </main>

  <aside class="inspector">
    <h3 style="margin:0 0 12px;">å±¬æ€§</h3>
    <div id="inspector-content">è«‹é¸æ“‡ç‰©ä»¶</div>
  </aside>
</div>

<script>
/* ========== Icons ========== */
lucide.createIcons();

/* ========== Helpers ========== */
function toast(msg, ms=1200){
  const el=document.getElementById('toast');
  el.textContent=msg; el.style.display='block';
  clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none', ms);
}
function safeInt(v,f=0){ const n=parseInt(v,10); return Number.isFinite(n)?n:f; }
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* ========== Units ========== */
const GRID_PX=10;
const MM_PER_GRID=100;
const MM_PER_PX=MM_PER_GRID/GRID_PX;
function pxToMm(px){ return Math.round(px*MM_PER_PX); }
function mmToPx(mm){ return mm/MM_PER_PX; }
function mmToCm(mm){ return mm/10; }
function fmtMm(mm){ return `${Math.round(mm)}mm`; }
function fmtCm(mm){ return `${Math.round(mmToCm(mm))}cm`; }
function snapPx(v){ return Math.round(v/GRID_PX)*GRID_PX; }

/* ========== Room (FIXED, no UI) ========== */
const ROOM={ widthMm:6000, depthMm:4000, wallHeightMm:2800, wallThicknessMm:100 };

/* ========== Placement Mode ========== */
let placementMode = null; // { kind:'device'|'zone'|'wall', key, label }
function setPlacementMode(mode){
  placementMode = mode;
  const pill=document.getElementById('placement-pill');
  const name=document.getElementById('placement-name');
  if(mode){
    name.textContent = mode.label || mode.key || mode.kind;
    pill.style.display='block';
    document.body.style.cursor = 'crosshair';
  }else{
    pill.style.display='none';
    document.body.style.cursor = 'default';
  }
}
function cancelPlacement(){ setPlacementMode(null); toast('å·²å–æ¶ˆæ”¾ç½®æ¨¡å¼'); }
window.addEventListener('keydown',(e)=>{
  const tag=document.activeElement?.tagName?.toLowerCase();
  const typing=tag==='input'||tag==='textarea';
  if(e.key==='Escape'){
    hideInfoCard();
    if(placementMode){ cancelPlacement(); return; }
    clearSelection();
    layer.draw();
    sync3DSelectionHighlight();
    return;
  }
  if(!typing && (e.key==='Delete'||e.key==='Backspace')){
    deleteSelected();
    e.preventDefault();
  }
});

/* ========== Catalog Data ========== */
const DEVICE_CATALOG=[
  { group:'instruments', key:'centrifuge', name:'é›¢å¿ƒæ©Ÿ', wMm:600, dMm:600, hMm:900, accent:'#38bdf8', icon:'settings' },
  { group:'instruments', key:'incubator', name:'åŸ¹é¤Šç®±', wMm:700, dMm:600, hMm:1600, accent:'#a78bfa', icon:'thermometer' },
  { group:'instruments', key:'fridge', name:'å†°ç®±', wMm:700, dMm:700, hMm:1800, accent:'#22c55e', icon:'snowflake' },
  { group:'instruments', key:'ultra_low_freezer', name:'è¶…ä½æº«å†°ç®±', wMm:800, dMm:800, hMm:2000, accent:'#22c55e', icon:'snowflake' },

  { group:'furniture', key:'bench', name:'å¯¦é©—æ¡Œ', wMm:1200, dMm:600, hMm:800, accent:'#60a5fa', icon:'table' },
  { group:'furniture', key:'hood', name:'æ’ç…™æ«ƒ', wMm:1000, dMm:800, hMm:2000, accent:'#60a5fa', icon:'wind' },
  { group:'furniture', key:'sink', name:'æ´—æ»Œæ§½', wMm:900, dMm:600, hMm:900, accent:'#60a5fa', icon:'droplets' },
];
const DEVICE_BY_KEY=new Map(DEVICE_CATALOG.map(d=>[d.key,d]));

/* Wall Catalog (reasonable defaults) */
const WALL_CATALOG = [
  { key:'wall_h_full', label:'æ°´å¹³éš”ç‰†', lengthMm:2000, thicknessMm:120, heightMm:2800, orientation:'h', icon:'ğŸ§±', sub:'2000Ã—120mm Â· 120mmåš' },
  { key:'wall_v_full', label:'å‚ç›´éš”ç‰†', lengthMm:2000, thicknessMm:120, heightMm:2800, orientation:'v', icon:'ğŸ§±', sub:'120Ã—2000mm Â· 120mmåš' },
  { key:'wall_h_panel', label:'æ°´å¹³éš”æ¿', lengthMm:1600, thicknessMm:60, heightMm:2800, orientation:'h', icon:'ğŸ§±', sub:'1600Ã—60mm Â· 60mmåš' },
  { key:'wall_v_panel', label:'å‚ç›´éš”æ¿', lengthMm:1600, thicknessMm:60, heightMm:2800, orientation:'v', icon:'ğŸ§±', sub:'60Ã—1600mm Â· 60mmåš' },
  { key:'wall_h_half', label:'æ°´å¹³åŠç‰†', lengthMm:1200, thicknessMm:100, heightMm:1200, orientation:'h', icon:'ğŸ§±', sub:'1200Ã—100mm Â· 100mmåš' },
  { key:'wall_v_half', label:'å‚ç›´åŠç‰†', lengthMm:1200, thicknessMm:100, heightMm:1200, orientation:'v', icon:'ğŸ§±', sub:'100Ã—1200mm Â· 100mmåš' },
];
const WALL_BY_KEY = new Map(WALL_CATALOG.map(w=>[w.key,w]));

/* ========== Sidebar Rendering ========== */
function renderDevices(){
  const instruments=document.getElementById('grp-instruments');
  const furniture=document.getElementById('grp-furniture');
  instruments.innerHTML=''; furniture.innerHTML='';

  DEVICE_CATALOG.forEach(d=>{
    const el=document.createElement('div');
    el.className='lib-item';
    el.dataset.action='place-device';
    el.dataset.key=d.key;
    el.dataset.name=d.name;
    el.dataset.sub=`${d.wMm}Ã—${d.dMm}mm`;
    el.innerHTML=`
      <div class="lib-icon">${iconForDevice(d)}</div>
      <div>
        <div class="lib-name">${escapeHtml(d.name)}</div>
        <div class="lib-sub">${d.wMm}Ã—${d.dMm}mm</div>
      </div>
    `;
    el.onclick=()=> setPlacementMode({ kind:'device', key:d.key, label:d.name });
    (d.group==='instruments'?instruments:furniture).appendChild(el);
  });
}
function iconForDevice(d){
  // simple unicode fallback; keeping it stable in sidebar
  const map = {
    centrifuge:'âš™ï¸',
    incubator:'ğŸŒ¡ï¸',
    fridge:'â„ï¸',
    ultra_low_freezer:'ğŸ§Š',
    bench:'ğŸ§±',
    hood:'ğŸŒ¬ï¸',
    sink:'ğŸ’§'
  };
  return map[d.key] || 'â¬š';
}
function renderWalls(){
  const root=document.getElementById('wall-items');
  root.innerHTML='';
  WALL_CATALOG.forEach(w=>{
    const el=document.createElement('div');
    el.className='lib-item';
    el.innerHTML=`
      <div class="lib-icon">${w.icon}</div>
      <div>
        <div class="lib-name">${escapeHtml(w.label)}</div>
        <div class="lib-sub">${escapeHtml(w.sub)}</div>
      </div>
    `;
    el.onclick = ()=> setPlacementMode({ kind:'wall', key:w.key, label:w.label });
    root.appendChild(el);
  });
}
function setupTabs(){
  document.querySelectorAll('.tab').forEach(tab=>{
    tab.addEventListener('click', ()=>{
      document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
      tab.classList.add('active');
      const name=tab.dataset.tab;
      document.getElementById('tab-devices').style.display = (name==='devices') ? 'block':'none';
      document.getElementById('tab-zones').style.display = (name==='zones') ? 'block':'none';
      document.getElementById('tab-walls').style.display = (name==='walls') ? 'block':'none';
    });
  });

  // collapse groups
  document.querySelectorAll('[data-collapse]').forEach(t=>{
    t.addEventListener('click', ()=>{
      const id=t.dataset.collapse;
      const el=document.getElementById(id);
      el.style.display = (el.style.display==='none') ? 'block' : 'none';
    });
  });

  // zone placement item
  document.querySelector('[data-action="place-zone"]').addEventListener('click', ()=>{
    setPlacementMode({ kind:'zone', key:'zone', label:'è¦åŠƒå€åŸŸ' });
  });
}

/* ========== Konva 2D ========== */
const stage=new Konva.Stage({ container:'container', width:window.innerWidth-640, height:window.innerHeight });
const gridLayer=new Konva.Layer();
const layer=new Konva.Layer();
stage.add(gridLayer); stage.add(layer);

// warning overlay
let warningLayer=null;
let warningLinesGroup=null;
function initWarningLayer(){
  if(warningLayer) return;
  warningLayer = new Konva.Layer();
  stage.add(warningLayer);
  warningLinesGroup = new Konva.Group({ name:'warnings', listening:false });
  warningLayer.add(warningLinesGroup);
}

const tr=new Konva.Transformer({
  keepRatio:false,
  rotateEnabled:true,
  enabledAnchors:['top-left','top-right','bottom-left','bottom-right','middle-left','middle-right','top-center','bottom-center']
});
layer.add(tr);

let selectedNodes=[];
let selectedNode=null;
let gridVisible=true;
let snapEnabled=true;

/* Grid */
function drawGrid(){
  gridLayer.destroyChildren();
  if(!gridVisible){ gridLayer.draw(); return; }
  const w=stage.width(), h=stage.height();
  for(let x=0;x<=w;x+=GRID_PX) gridLayer.add(new Konva.Line({ points:[x,0,x,h], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  for(let y=0;y<=h;y+=GRID_PX) gridLayer.add(new Konva.Line({ points:[0,y,w,y], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  gridLayer.draw();
}
function toggleGrid(){ gridVisible=!gridVisible; drawGrid(); if(warningLayer) warningLayer.draw(); scheduleAutosave(); }
function toggleSnap(){ snapEnabled=!snapEnabled; scheduleAutosave(); }

/* Room boundary 2D (fixed) */
let roomRect2D=null;
function drawRoomBoundary2D(){
  if(roomRect2D) roomRect2D.destroy();
  const wPx=mmToPx(ROOM.widthMm), dPx=mmToPx(ROOM.depthMm);
  roomRect2D=new Konva.Rect({
    x:snapPx((stage.width()-wPx)/2),
    y:snapPx((stage.height()-dPx)/2),
    width:wPx, height:dPx,
    stroke:'rgba(15,23,42,0.45)', strokeWidth:2,
    fill:'rgba(15,23,42,0.03)',
    listening:false,
    name:'room-boundary'
  });
  gridLayer.add(roomRect2D);
  gridLayer.draw();
}
function getRoomRectPx(){ if(!roomRect2D) drawRoomBoundary2D(); return roomRect2D.getClientRect(); }

/* Selection rect */
let selecting=false;
let selectionRect=new Konva.Rect({
  x:0,y:0,width:0,height:0,
  fill:'rgba(59,130,246,0.12)',
  stroke:'rgba(59,130,246,0.9)',
  strokeWidth:1,
  visible:false,
  listening:false
});
layer.add(selectionRect);
let startPos=null;

/* ========== Nodes creation ========== */
const SAFETY_CLEARANCE_MM_DEFAULT=100;

// used for restoring stroke after conflict cleared
const DEFAULT_STROKE_BY_KIND = {
  device: '#1e293b',
  zone: '#3b82f6',
  wall: '#fb923c'
};

function createNode(kind, name, wPx, dPx, hPx, fill, stroke, key, extra={}){
  const group=new Konva.Group({
    x:100, y:100,
    draggable:true,
    name: kind,
    customData: Object.assign({
      height3dPx: hPx||0,
      deviceKey: key,
      clearanceMm: SAFETY_CLEARANCE_MM_DEFAULT,
      accent: extra.accent || '#60a5fa',
      wallThicknessMm: extra.wallThicknessMm || 0,
      wallHeightMm: extra.wallHeightMm || 0
    }, extra)
  });

  const rect=new Konva.Rect({
    width:wPx,
    height:dPx,
    fill, stroke,
    strokeWidth: 1,
    name:'main-rect',
    dash: kind==='zone' ? [10,5] : []
  });

  const title=new Konva.Text({
    text:name,
    fontSize:13,
    fill:stroke,
    padding:8,
    name:'title-text'
  });

  const dim=new Konva.Text({ text:'', fontSize:10, fill:stroke, name:'dim-label' });

  group.add(rect,title,dim);
  updateUI(group);

  group.on('dragmove',()=>{
    if(snapEnabled) group.position({ x:snapPx(group.x()), y:snapPx(group.y()) });
    constrainToRoom(group);
    if(kind==='device') maybeSnapDeviceToWalls(group);
    updateUI(group);
    scheduleAutosave();
    scheduleCollisionCheck();
  });
  group.on('dragend',()=>{ scheduleAutosave(); scheduleCollisionCheck(); });
  group.on('transform',()=>{ updateUI(group); scheduleAutosave(); scheduleCollisionCheck(); });
  group.on('transformend',()=>{
    if(snapEnabled) normalizeGroupToGrid(group);
    constrainToRoom(group);
    if(kind==='device') maybeSnapDeviceToWalls(group);
    scheduleAutosave();
    scheduleCollisionCheck();
    if(is3DVisible()) update3D();
  });

  group.on('click tap',(e)=>{
    e.cancelBubble=true;
    const multi=e.evt && e.evt.shiftKey;
    if(multi) toggleSelectNode(group); else selectSingleNode(group);
  });

  layer.add(group);
  if(kind==='zone') group.moveToBottom();

  selectSingleNode(group);
  layer.draw();

  scheduleAutosave();
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();

  return group;
}

function addDeviceByKey(key, x, y){
  const d = DEVICE_BY_KEY.get(key);
  if(!d) return;
  const node = createNode(
    'device',
    d.name,
    mmToPx(d.wMm),
    mmToPx(d.dMm),
    mmToPx(d.hMm),
    'rgba(148,163,184,0.10)',
    DEFAULT_STROKE_BY_KIND.device,
    d.key,
    { accent: d.accent }
  );
  node.position({ x, y });
  if(snapEnabled) node.position({ x:snapPx(x), y:snapPx(y) });
  constrainToRoom(node);
  updateUI(node);
  layer.draw();
}

function addZoneAt(x, y){
  const node = createNode(
    'zone',
    'è¦åŠƒå€åŸŸ',
    mmToPx(3000),
    mmToPx(2000),
    0,
    'rgba(59,130,246,0.10)',
    DEFAULT_STROKE_BY_KIND.zone,
    'zone',
    {}
  );
  node.position({ x, y });
  if(snapEnabled) node.position({ x:snapPx(x), y:snapPx(y) });
  constrainToRoom(node);
  updateUI(node);
  layer.draw();
}

function addWallByKey(key, x, y){
  const w = WALL_BY_KEY.get(key);
  if(!w) return;

  const lenPx = mmToPx(w.lengthMm);
  const thPx = mmToPx(w.thicknessMm);

  const widthPx = (w.orientation === 'h') ? lenPx : thPx;
  const heightPx = (w.orientation === 'h') ? thPx : lenPx;

  const node = createNode(
    'wall',
    w.label,
    widthPx,
    heightPx,
    0,
    'rgba(251, 146, 60, 0.15)',
    DEFAULT_STROKE_BY_KIND.wall,
    w.key,
    { wallThicknessMm: w.thicknessMm, wallHeightMm: w.heightMm, wallOrientation: w.orientation }
  );

  node.position({ x, y });
  if(snapEnabled) node.position({ x:snapPx(x), y:snapPx(y) });
  constrainToRoom(node);
  updateUI(node);
  layer.draw();
}

/* normalize sizes after transformer */
function normalizeGroupToGrid(group){
  group.x(snapPx(group.x()));
  group.y(snapPx(group.y()));
  const rect = group.findOne('.main-rect');
  const absW = rect.width()*group.scaleX();
  const absH = rect.height()*group.scaleY();
  const targetW = Math.max(GRID_PX, snapPx(absW));
  const targetH = Math.max(GRID_PX, snapPx(absH));
  group.scaleX(targetW/rect.width());
  group.scaleY(targetH/rect.height());
}
function constrainToRoom(group){
  const rr=getRoomRectPx();
  const r=group.findOne('.main-rect');
  const w=r.width()*group.scaleX();
  const h=r.height()*group.scaleY();
  group.position({
    x: clamp(group.x(), rr.x, rr.x+rr.width-w),
    y: clamp(group.y(), rr.y, rr.y+rr.height-h)
  });
}
function updateUI(group){
  const rect=group.findOne('.main-rect');
  const dim=group.findOne('.dim-label');

  const wPx = rect.width()*group.scaleX();
  const dPx = rect.height()*group.scaleY();

  dim.text(`${fmtMm(pxToMm(wPx))}Ã—${fmtMm(pxToMm(dPx))}`);
  dim.x(rect.width()-dim.width()-5);
  dim.y(rect.height()-15);

  // conflict rendering
  if(group.name()==='device'){
    if(conflictIds.has(group._id)){
      const hard = collisionPairs.some(p => p.type==='overlap' && (p.aId===group._id || p.bId===group._id));
      rect.stroke(hard ? '#ef4444' : '#f59e0b');
      rect.strokeWidth(2);
    }else{
      rect.stroke(DEFAULT_STROKE_BY_KIND.device);
      rect.strokeWidth(1);
    }
  }else if(group.name()==='wall'){
    rect.stroke(DEFAULT_STROKE_BY_KIND.wall);
    rect.strokeWidth(2);
  }

  if(selectedNodes.includes(group)) renderInspector();
}

/* ========== Selection ========== */
function applyTransformer(){
  tr.nodes(selectedNodes);
  layer.draw();
  sync3DSelectionHighlight();
  if(is3DVisible()) sync3DConflictHighlight();
}
function clearSelection(){
  selectedNodes=[]; selectedNode=null;
  applyTransformer();
  renderInspector();
}
function selectSingleNode(node){
  selectedNodes=[node]; selectedNode=node;
  applyTransformer(); renderInspector();
}
function toggleSelectNode(node){
  const idx=selectedNodes.indexOf(node);
  if(idx>=0) selectedNodes.splice(idx,1); else selectedNodes.push(node);
  selectedNode = selectedNodes.length===1 ? selectedNodes[0] : null;
  applyTransformer(); renderInspector();
}

/* ========== Stage interactions ========== */
stage.on('click tap', (e)=>{
  // placement mode: click to place at pointer
  if(placementMode && e.target===stage){
    const p = stage.getPointerPosition();
    if(!p) return;
    const x = p.x, y = p.y;

    if(placementMode.kind === 'device') addDeviceByKey(placementMode.key, x, y);
    if(placementMode.kind === 'zone') addZoneAt(x, y);
    if(placementMode.kind === 'wall') addWallByKey(placementMode.key, x, y);

    // exit after place
    setPlacementMode(null);
    return;
  }

  // normal clear selection
  if(e.target===stage){
    clearSelection();
    if(is3DVisible()) update3D();
  }
});

stage.on('mousedown touchstart',(e)=>{
  if(is3DVisible()) return;
  if(placementMode) return; // don't marquee while in placement
  if(e.target!==stage) return;
  selecting=true;
  startPos=stage.getPointerPosition();
  selectionRect.visible(true);
  selectionRect.position(startPos);
  selectionRect.size({width:0,height:0});
  layer.draw();
});
stage.on('mousemove touchmove',()=>{
  if(!selecting) return;
  const pos=stage.getPointerPosition(); if(!pos) return;
  const x=Math.min(startPos.x,pos.x);
  const y=Math.min(startPos.y,pos.y);
  const w=Math.abs(pos.x-startPos.x);
  const h=Math.abs(pos.y-startPos.y);
  selectionRect.setAttrs({x,y,width:w,height:h});
  layer.batchDraw();
});
stage.on('mouseup touchend',(e)=>{
  if(!selecting) return;
  selecting=false;
  selectionRect.visible(false);
  layer.draw();
  const box=selectionRect.getClientRect();
  const groups=layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'||n.name()==='wall'));
  const additive=e.evt && e.evt.shiftKey;
  const hits=groups.filter(g=>Konva.Util.haveIntersection(box, g.getClientRect()));
  if(!additive) selectedNodes=[];
  hits.forEach(g=>{ if(!selectedNodes.includes(g)) selectedNodes.push(g); });
  selectedNode = selectedNodes.length===1 ? selectedNodes[0] : null;
  applyTransformer(); renderInspector();
  if(is3DVisible()) update3D();
});

/* ========== Wall snapping (device->wall) ========== */
function maybeSnapDeviceToWalls(deviceGroup){
  // Axis-aligned snapping based on 2D client rects (simple & stable)
  const SNAP_MM = 50;
  const snapPxTol = mmToPx(SNAP_MM);

  const devRect = deviceGroup.getClientRect();
  const walls = layer.getChildren().filter(n=>n instanceof Konva.Group && n.name()==='wall');
  if(walls.length===0) return;

  // choose nearest snap
  let best = null;

  walls.forEach(w=>{
    const wr = w.getClientRect();

    // snap dev left to wall right (touch)
    const dx1 = Math.abs(devRect.x - (wr.x + wr.width));
    if(dx1 < snapPxTol) best = chooseBest(best, { type:'x', value: (wr.x + wr.width) - devRect.x });

    // snap dev right to wall left
    const dx2 = Math.abs((devRect.x+devRect.width) - wr.x);
    if(dx2 < snapPxTol) best = chooseBest(best, { type:'x', value: wr.x - (devRect.x+devRect.width) });

    // snap dev top to wall bottom
    const dy1 = Math.abs(devRect.y - (wr.y + wr.height));
    if(dy1 < snapPxTol) best = chooseBest(best, { type:'y', value: (wr.y + wr.height) - devRect.y });

    // snap dev bottom to wall top
    const dy2 = Math.abs((devRect.y+devRect.height) - wr.y);
    if(dy2 < snapPxTol) best = chooseBest(best, { type:'y', value: wr.y - (devRect.y+devRect.height) });
  });

  if(!best) return;

  // Apply delta to group position
  if(best.type==='x') deviceGroup.x(deviceGroup.x() + best.value);
  if(best.type==='y') deviceGroup.y(deviceGroup.y() + best.value);

  if(snapEnabled){
    deviceGroup.position({ x:snapPx(deviceGroup.x()), y:snapPx(deviceGroup.y()) });
  }
  constrainToRoom(deviceGroup);

  function chooseBest(curr, cand){
    if(!curr) return cand;
    return Math.abs(cand.value) < Math.abs(curr.value) ? cand : curr;
  }
}

/* ========== 7A v2 collision/clearance + distance lines (devices only) ========== */
let collisionPairs=[]; // {aId,bId,type,gapMm,needMm,seg}
let conflictIds=new Set();
let collisionTimer=null;

function scheduleCollisionCheck(){
  clearTimeout(collisionTimer);
  collisionTimer=setTimeout(recomputeCollisions, 80);
}
function rectsOverlap(a,b){
  return !(a.x+a.width<=b.x || b.x+b.width<=a.x || a.y+a.height<=b.y || b.y+b.height<=a.y);
}
function getClosestSegmentBetweenRects(a,b){
  const ax1=a.x, ax2=a.x+a.width, ay1=a.y, ay2=a.y+a.height;
  const bx1=b.x, bx2=b.x+b.width, by1=b.y, by2=b.y+b.height;

  function clampPointToRect(px,py, r){
    const rx1=r.x, rx2=r.x+r.width, ry1=r.y, ry2=r.y+r.height;
    return { x: clamp(px, rx1, rx2), y: clamp(py, ry1, ry2) };
  }

  const acx=(ax1+ax2)/2, acy=(ay1+ay2)/2;
  const bcx=(bx1+bx2)/2, bcy=(by1+by2)/2;

  let best = {
    ax: clampPointToRect(bcx, bcy, a).x,
    ay: clampPointToRect(bcx, bcy, a).y,
    bx: clampPointToRect(acx, acy, b).x,
    by: clampPointToRect(acx, acy, b).y
  };

  function dist2(s){ const dx=s.ax-s.bx, dy=s.ay-s.by; return dx*dx+dy*dy; }
  let bestD2=dist2(best);

  if(ax2 < bx1){
    const y = clamp(acy, by1, by2);
    const s = { ax: ax2, ay: clamp(y, ay1, ay2), bx: bx1, by: y };
    const d2=dist2(s); if(d2<bestD2){ best=s; bestD2=d2; }
  } else if(bx2 < ax1){
    const y = clamp(bcy, ay1, ay2);
    const s = { ax: ax1, ay: y, bx: bx2, by: clamp(y, by1, by2) };
    const d2=dist2(s); if(d2<bestD2){ best=s; bestD2=d2; }
  }

  if(ay2 < by1){
    const x = clamp(acx, bx1, bx2);
    const s = { ax: clamp(x, ax1, ax2), ay: ay2, bx: x, by: by1 };
    const d2=dist2(s); if(d2<bestD2){ best=s; bestD2=d2; }
  } else if(by2 < ay1){
    const x = clamp(bcx, ax1, ax2);
    const s = { ax: x, ay: ay1, bx: clamp(x, bx1, bx2), by: by2 };
    const d2=dist2(s); if(d2<bestD2){ best=s; bestD2=d2; }
  }

  return best;
}

function recomputeCollisions(){
  initWarningLayer();
  warningLinesGroup.destroyChildren();

  const devices=layer.getChildren().filter(n=>n instanceof Konva.Group && n.name()==='device');
  collisionPairs=[];
  conflictIds=new Set();

  for(let i=0;i<devices.length;i++){
    for(let j=i+1;j<devices.length;j++){
      const A=devices[i], B=devices[j];
      const ra=A.getClientRect();
      const rb=B.getClientRect();

      if(rectsOverlap(ra, rb)){
        collisionPairs.push({ aId:A._id, bId:B._id, type:'overlap', gapMm:0, needMm:0, seg:null });
        conflictIds.add(A._id); conflictIds.add(B._id);
        continue;
      }

      const ca=A.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT;
      const cb=B.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT;
      const needMm=Math.max(ca, cb);

      const seg=getClosestSegmentBetweenRects(ra, rb);
      const dx=seg.ax-seg.bx, dy=seg.ay-seg.by;
      const gapPx=Math.sqrt(dx*dx+dy*dy);
      const gapMm=pxToMm(gapPx);

      if(gapMm < needMm){
        collisionPairs.push({ aId:A._id, bId:B._id, type:'clearance', gapMm, needMm, seg });
        conflictIds.add(A._id); conflictIds.add(B._id);

        const line=new Konva.Line({ points:[seg.ax,seg.ay,seg.bx,seg.by], stroke:'rgba(245,158,11,0.95)', strokeWidth:2, dash:[8,6] });
        const midx=(seg.ax+seg.bx)/2, midy=(seg.ay+seg.by)/2;
        const text=new Konva.Text({ x:midx+6, y:midy+6, text:`${gapMm}mm / éœ€â‰¥${needMm}mm`, fontSize:12, fill:'#b45309' });
        const bg=new Konva.Rect({ x:text.x()-4, y:text.y()-2, width:text.width()+8, height:text.height()+4, fill:'rgba(255,237,213,0.75)', stroke:'rgba(245,158,11,0.65)', strokeWidth:1, cornerRadius:6 });
        warningLinesGroup.add(line,bg,text);
      }
    }
  }

  devices.forEach(updateUI);
  layer.draw();
  warningLayer.draw();
  renderInspector();
  if(is3DVisible()) sync3DConflictHighlight();
}

/* ========== Inspector ========== */
function renderInspector(){
  const c=document.getElementById('inspector-content');

  if(selectedNodes.length===0){
    c.innerHTML=`
      <div class="chip">æœªé¸å–</div>
      <div style="margin-top:10px; color:#94a3b8; font-size:12px;">
        è¡çªï¼š<b>${collisionPairs.length}</b> çµ„ï¼ˆç´…=é‡ç–Šï¼›æ©˜=è·é›¢ä¸è¶³ï¼‰
      </div>
    `;
    return;
  }

  if(selectedNodes.length>1){
    c.innerHTML=`
      <div class="chip">å·²é¸å–ï¼š${selectedNodes.length} å€‹</div>
      <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">åˆªé™¤é¸å–</button>
    `;
    return;
  }

  const n=selectedNodes[0];
  const r=n.findOne('.main-rect');
  const wPx=r.width()*n.scaleX();
  const dPx=r.height()*n.scaleY();
  const kind=n.name();

  if(kind==='device'){
    const hPx=n.attrs.customData?.height3dPx||0;
    const key=n.attrs.customData?.deviceKey||'device';
    const clearance=n.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT;

    c.innerHTML=`
      <div class="chip">è¨­å‚™ï¼š${escapeHtml(key)}</div>
      <div style="margin-top:10px; color:#94a3b8; font-size:12px; line-height:1.4;">
        å°ºå¯¸ï¼š<b>${fmtMm(pxToMm(wPx))}Ã—${fmtMm(pxToMm(dPx))}</b><br/>
        é«˜åº¦ï¼š<b>${fmtCm(pxToMm(hPx))}</b>
      </div>
      <div class="prop-group" style="margin-top:12px;">
        <label class="prop-label">å®‰å…¨è·é›¢ (mm)</label>
        <input type="number" value="${clearance}" oninput="updateClearance(this.value)">
      </div>
      <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">åˆªé™¤ç‰©ä»¶</button>
    `;
    return;
  }

  if(kind==='zone'){
    c.innerHTML=`
      <div class="chip">å€åŸŸ</div>
      <div style="margin-top:10px; color:#94a3b8; font-size:12px;">
        å°ºå¯¸ï¼š<b>${fmtMm(pxToMm(wPx))}Ã—${fmtMm(pxToMm(dPx))}</b>
      </div>
      <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">åˆªé™¤ç‰©ä»¶</button>
    `;
    return;
  }

  if(kind==='wall'){
    const wallKey=n.attrs.customData?.deviceKey||'wall';
    const th=n.attrs.customData?.wallThicknessMm||0;
    const wh=n.attrs.customData?.wallHeightMm||0;
    c.innerHTML=`
      <div class="chip">ç‰†å£ï¼š${escapeHtml(wallKey)}</div>
      <div style="margin-top:10px; color:#94a3b8; font-size:12px; line-height:1.4;">
        å¹³é¢ï¼š<b>${fmtMm(pxToMm(wPx))}Ã—${fmtMm(pxToMm(dPx))}</b><br/>
        åšåº¦ï¼š<b>${th}mm</b> / ç‰†é«˜ï¼š<b>${wh}mm</b>
      </div>
      <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">åˆªé™¤ç‰©ä»¶</button>
    `;
    return;
  }
}

function updateClearance(v){
  if(selectedNodes.length!==1) return;
  const mm=Math.max(0, safeInt(v, SAFETY_CLEARANCE_MM_DEFAULT));
  selectedNodes[0].attrs.customData.clearanceMm=mm;
  scheduleAutosave();
  scheduleCollisionCheck();
}

/* ========== Delete / Export ========== */
function deleteSelected(){
  if(selectedNodes.length===0) return;
  selectedNodes.forEach(n=>n.destroy());
  clearSelection();
  layer.draw();
  scheduleAutosave();
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();
}

function exportImg(format){
  tr.nodes([]);
  layer.draw();
  if(format==='png'){
    const a=document.createElement('a');
    a.download='lab.png';
    a.href=stage.toDataURL();
    a.click();
  }else{
    const doc=new jspdf.jsPDF('l','px',[stage.width(), stage.height()]);
    doc.addImage(stage.toDataURL(), 'PNG', 0,0, stage.width(), stage.height());
    doc.save('lab.pdf');
  }
}

/* ========== Save/Load JSON ========== */
const STORAGE_KEY='labcad_design_v1';
let autosaveTimer=null;

function scheduleAutosave(){
  clearTimeout(autosaveTimer);
  autosaveTimer=setTimeout(()=>{
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(getDesignJSON())); }
    catch(err){ console.error(err); toast('è‡ªå‹•ä¿å­˜å¤±æ•—'); }
  }, 150);
}

function serializeNode(group){
  const r=group.findOne('.main-rect');
  const title=group.findOne('.title-text');
  const wPx=r.width()*group.scaleX();
  const dPx=r.height()*group.scaleY();
  const hPx=group.attrs.customData?.height3dPx||0;

  return {
    type: group.name(),
    key: group.attrs.customData?.deviceKey || group.name(),
    name: title ? title.text() : '',
    xMm: pxToMm(group.x()),
    yMm: pxToMm(group.y()),
    wMm: pxToMm(wPx),
    dMm: pxToMm(dPx),
    rot: group.rotation(),
    fill: r.fill(),
    stroke: r.stroke(),
    dash: r.dash(),
    hMm: pxToMm(hPx),
    clearanceMm: group.attrs.customData?.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT,
    accent: group.attrs.customData?.accent ?? '#60a5fa',
    wallThicknessMm: group.attrs.customData?.wallThicknessMm ?? 0,
    wallHeightMm: group.attrs.customData?.wallHeightMm ?? 0,
    wallOrientation: group.attrs.customData?.wallOrientation ?? ''
  };
}
function getDesignJSON(){
  const nodes=layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'||n.name()==='wall')).map(serializeNode);
  return {
    version: 90,
    savedAt: new Date().toISOString(),
    units: { gridPx: GRID_PX, mmPerGrid: MM_PER_GRID },
    room: { ...ROOM },
    ui: { gridVisible, snapEnabled },
    nodes
  };
}
function downloadText(filename,text,mime='application/json'){
  const blob=new Blob([text],{type:mime});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download=filename;
  document.body.appendChild(a); a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
function exportDesignJSON(){ downloadText('labcad-design.json', JSON.stringify(getDesignJSON(), null, 2)); toast('å·²åŒ¯å‡º JSON'); }

function triggerImportJSON(){ document.getElementById('import-json-input').click(); }
document.getElementById('import-json-input').addEventListener('change',(e)=>{
  const file=e.target.files && e.target.files[0];
  if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{ loadDesignFromObject(JSON.parse(reader.result)); toast('å·²åŒ¯å…¥ JSON'); }
    catch(err){ console.error(err); toast('åŒ¯å…¥å¤±æ•—'); }
    finally{ e.target.value=''; }
  };
  reader.readAsText(file);
});

function resetDesign(clearLS=false){
  layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'||n.name()==='wall')).forEach(g=>g.destroy());
  selectionRect.visible(false);
  clearSelection();
  layer.draw();
  if(clearLS){ localStorage.removeItem(STORAGE_KEY); toast('å·²æ¸…ç©ºè¨­è¨ˆ'); }
  if(warningLinesGroup) warningLinesGroup.destroyChildren();
  scheduleCollisionCheck();
  if(warningLayer) warningLayer.draw();
  if(is3DVisible()) update3D();
}

function loadDesignFromObject(design){
  resetDesign(false);

  if(design?.ui){
    gridVisible = design.ui.gridVisible ?? gridVisible;
    snapEnabled = design.ui.snapEnabled ?? snapEnabled;
  }

  (design?.nodes||[]).forEach(n=>{
    const type = (n.type==='wall') ? 'wall' : (n.type==='zone' ? 'zone' : 'device');
    const stroke = n.stroke || DEFAULT_STROKE_BY_KIND[type] || '#1e293b';
    const dash = Array.isArray(n.dash) ? n.dash : (type==='zone' ? [10,5] : []);
    const fill = n.fill || (type==='zone' ? 'rgba(59,130,246,0.10)' : (type==='wall' ? 'rgba(251,146,60,0.15)' : 'rgba(148,163,184,0.10)'));

    const group=new Konva.Group({
      x: mmToPx(Number(n.xMm)||0),
      y: mmToPx(Number(n.yMm)||0),
      draggable:true,
      name:type,
      customData:{
        height3dPx: mmToPx(Number(n.hMm)||0),
        deviceKey: n.key || type,
        clearanceMm: Number(n.clearanceMm ?? SAFETY_CLEARANCE_MM_DEFAULT),
        accent: n.accent ?? '#60a5fa',
        wallThicknessMm: Number(n.wallThicknessMm||0),
        wallHeightMm: Number(n.wallHeightMm||0),
        wallOrientation: n.wallOrientation || ''
      }
    });

    const rect=new Konva.Rect({
      width: mmToPx(Math.max(10, Number(n.wMm)||100)),
      height: mmToPx(Math.max(10, Number(n.dMm)||100)),
      fill, stroke, name:'main-rect', dash, strokeWidth: (type==='wall'?2:1)
    });

    const title=new Konva.Text({ text:n.name||'', fontSize:13, fill:stroke, padding:8, name:'title-text' });
    const dim=new Konva.Text({ text:'', fontSize:10, fill:stroke, name:'dim-label' });

    group.rotation(Number(n.rot)||0);
    group.add(rect,title,dim);
    updateUI(group);

    group.on('dragmove',()=>{
      if(snapEnabled) group.position({ x:snapPx(group.x()), y:snapPx(group.y()) });
      constrainToRoom(group);
      if(type==='device') maybeSnapDeviceToWalls(group);
      updateUI(group);
      scheduleAutosave();
      scheduleCollisionCheck();
    });
    group.on('dragend',()=>{ scheduleAutosave(); scheduleCollisionCheck(); });
    group.on('transform',()=>{ updateUI(group); scheduleAutosave(); scheduleCollisionCheck(); });
    group.on('transformend',()=>{
      if(snapEnabled) normalizeGroupToGrid(group);
      constrainToRoom(group);
      if(type==='device') maybeSnapDeviceToWalls(group);
      scheduleAutosave();
      scheduleCollisionCheck();
      if(is3DVisible()) update3D();
    });
    group.on('click tap',(e)=>{
      e.cancelBubble=true;
      const multi=e.evt && e.evt.shiftKey;
      if(multi) toggleSelectNode(group); else selectSingleNode(group);
    });

    layer.add(group);
    if(type==='zone') group.moveToBottom();
  });

  drawGrid(); drawRoomBoundary2D(); layer.draw();
  scheduleAutosave();
  scheduleCollisionCheck();
  if(is3DVisible()) update3D();
}

function tryLoadFromLocalStorage(){
  const raw=localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{ loadDesignFromObject(JSON.parse(raw)); toast('å·²å¾è‡ªå‹•ä¿å­˜è¼‰å…¥'); }
  catch(err){ console.warn(err); }
}

/* ========== 3D rounded geometry (approx) ========== */
function createRoundedRectShape(w, h, r){
  const x=-w/2, y=-h/2;
  const shape=new THREE.Shape();
  const rr=Math.max(0, Math.min(r, Math.min(w,h)/2));
  shape.moveTo(x+rr,y);
  shape.lineTo(x+w-rr,y);
  shape.quadraticCurveTo(x+w,y,x+w,y+rr);
  shape.lineTo(x+w,y+h-rr);
  shape.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
  shape.lineTo(x+rr,y+h);
  shape.quadraticCurveTo(x,y+h,x,y+h-rr);
  shape.lineTo(x,y+rr);
  shape.quadraticCurveTo(x,y,x+rr,y);
  return shape;
}
function makeRoundedBoxGeo(w,h,d,radius,smoothSteps=5){
  const shape=createRoundedRectShape(w,h,radius);
  const geo=new THREE.ExtrudeGeometry(shape,{ depth:d, bevelEnabled:false, curveSegments:smoothSteps });
  geo.translate(0,0,-d/2);
  geo.computeVertexNormals();
  return geo;
}

/* materials */
const MAT = {
  body: new THREE.MeshStandardMaterial({ color:0xf1f5f9, roughness:0.85, metalness:0.02 }),
  body2: new THREE.MeshStandardMaterial({ color:0xe5e7eb, roughness:0.85, metalness:0.02 }),
  base: new THREE.MeshStandardMaterial({ color:0x334155, roughness:0.92, metalness:0.08 }),
  base2: new THREE.MeshStandardMaterial({ color:0x111827, roughness:0.95, metalness:0.02 }),
  metal: new THREE.MeshStandardMaterial({ color:0xcbd5e1, roughness:0.28, metalness:0.75 }),
  glass: new THREE.MeshStandardMaterial({ color:0x93c5fd, transparent:true, opacity:0.18, roughness:0.12, metalness:0.0 }),
  panelBlue: (function(){
    const m=new THREE.MeshStandardMaterial({ color:0x0b1220, roughness:0.5, metalness:0.05 });
    m.emissive=new THREE.Color(0x60a5fa);
    m.emissiveIntensity=0.85;
    return m;
  })()
};
function makeAccentMat(hex){ return new THREE.MeshStandardMaterial({ color:new THREE.Color(hex), roughness:0.55, metalness:0.08 }); }
function addAccentStripe(root,x,y,z,w,h,accentHex){
  const geo=makeRoundedBoxGeo(w,h,6,Math.min(6,w*0.25),3);
  const mesh=new THREE.Mesh(geo, makeAccentMat(accentHex));
  mesh.position.set(x,y,z);
  root.add(mesh);
}
function addDoorPanel(root,x,y,z,w,h,radius){
  const geo=makeRoundedBoxGeo(w,h,6,Math.min(10,radius),4);
  const mesh=new THREE.Mesh(geo, MAT.body2);
  mesh.position.set(x,y,z);
  root.add(mesh);
}
function addHandle(root,x,y,z,len){
  const geo=new THREE.CylinderGeometry(7,7,len,12);
  const mesh=new THREE.Mesh(geo, MAT.metal);
  mesh.position.set(x,y,z);
  mesh.castShadow=true;
  root.add(mesh);
}
function addPanel(root,x,y,z,w,h){
  const geo=makeRoundedBoxGeo(w,h,10,Math.min(8,w*0.08),3);
  const mesh=new THREE.Mesh(geo, MAT.panelBlue);
  mesh.position.set(x,y,z);
  root.add(mesh);
}

/* prefabs */
function buildBench3D(w,d,h){
  const root=new THREE.Group();
  const top=new THREE.Mesh(makeRoundedBoxGeo(w,44,d,16,5), MAT.body);
  top.position.set(0,h-22,0);
  root.add(top);

  const legH=h-70;
  const legGeo=makeRoundedBoxGeo(22,legH,22,6,3);
  [[-w/2+22, legH/2, -d/2+22],[w/2-22, legH/2, -d/2+22],[-w/2+22, legH/2, d/2-22],[w/2-22, legH/2, d/2-22]]
    .forEach(([x,y,z])=>{ const leg=new THREE.Mesh(legGeo, MAT.base); leg.position.set(x,y,z); root.add(leg); });

  return { root, pickHeight:h };
}
function buildFridgeLike3D(w,d,h, accentHex){
  const root=new THREE.Group();
  const radius=Math.min(22, Math.min(w,d)*0.08);

  const plinth=new THREE.Mesh(makeRoundedBoxGeo(w*0.96, 40, d*0.96, 12, 3), MAT.base);
  plinth.position.set(0,20,0);
  root.add(plinth);

  const body=new THREE.Mesh(makeRoundedBoxGeo(w,h,d,radius,6), MAT.body);
  body.position.set(0,h/2+40,0);
  root.add(body);

  addDoorPanel(root,0,h/2+40,d/2+4,w*0.9,h*0.88,radius);
  addHandle(root,w/2-36,h/2+40,d/2+16,h*0.45);
  addPanel(root,0,h+40-120,d/2+14,w*0.5,74);
  addAccentStripe(root,w*0.22,h+40-170,d/2+16,w*0.35,20,accentHex);

  return { root, pickHeight:h+40 };
}
function buildIncubator3D(w,d,h,accentHex){
  const root=new THREE.Group();
  const radius=Math.min(22, Math.min(w,d)*0.08);

  const base=new THREE.Mesh(makeRoundedBoxGeo(w*0.96, 40, d*0.96, 12, 3), MAT.base);
  base.position.set(0,20,0);
  root.add(base);

  const body=new THREE.Mesh(makeRoundedBoxGeo(w,h,d,radius,6), MAT.body);
  body.position.set(0,h/2+40,0);
  root.add(body);

  const glass=new THREE.Mesh(makeRoundedBoxGeo(w*0.82,h*0.74,8,Math.min(18,radius),5), MAT.glass);
  glass.position.set(0,h/2+40,d/2+10);
  root.add(glass);

  addPanel(root,0,h+40-120,d/2+14,w*0.5,74);
  addAccentStripe(root,w*0.22,h+40-170,d/2+16,w*0.35,20,accentHex);
  addHandle(root,w/2-36,h/2+40,d/2+16,h*0.45);

  return { root, pickHeight:h+40 };
}
function buildCentrifuge3D(w,d,h,accentHex){
  const root=new THREE.Group();
  const baseH=h*0.55;

  const base=new THREE.Mesh(makeRoundedBoxGeo(w,baseH,d,Math.min(18,Math.min(w,d)*0.08),5), MAT.base);
  base.position.set(0,baseH/2,0);
  root.add(base);

  const lid=new THREE.Mesh(new THREE.CylinderGeometry(Math.min(w,d)*0.38,Math.min(w,d)*0.38,h*0.28,28), MAT.body2);
  lid.position.set(0,baseH+h*0.14,0);
  root.add(lid);

  addPanel(root,w*0.18,baseH*0.65,d/2+14,w*0.42,h*0.22);
  addAccentStripe(root,-w*0.15,baseH*0.55,d/2+14,w*0.28,18,accentHex);

  return { root, pickHeight:h };
}
function buildSink3D(w,d,h,accentHex){
  const root=new THREE.Group();

  const cab=new THREE.Mesh(makeRoundedBoxGeo(w*0.92,h-60,d*0.92,16,5), MAT.body2);
  cab.position.set(0,(h-60)/2,0);
  root.add(cab);

  const top=new THREE.Mesh(makeRoundedBoxGeo(w,44,d,16,6), MAT.body);
  top.position.set(0,h-22,0);
  root.add(top);

  const basin=new THREE.Mesh(makeRoundedBoxGeo(w*0.55,26,d*0.45,14,5), MAT.base2);
  basin.position.set(-w*0.08,h-30,0);
  root.add(basin);

  const post=new THREE.Mesh(new THREE.CylinderGeometry(10,10,120,14), MAT.metal);
  post.position.set(w*0.2,h+30,0);
  root.add(post);

  const spout=new THREE.Mesh(new THREE.CylinderGeometry(8,8,120,14), MAT.metal);
  spout.rotation.z=Math.PI/2;
  spout.position.set(w*0.2+55,h+70,0);
  root.add(spout);

  addHandle(root,w*0.35,(h-60)/2,d/2+14,(h-60)*0.35);
  addAccentStripe(root,-w*0.18,(h-60)/2,d/2+14,w*0.28,18,accentHex);

  return { root, pickHeight:h };
}
function buildHood3D(w,d,h,accentHex){
  const root=new THREE.Group();
  const radius=Math.min(22, Math.min(w,d)*0.08);

  const base=new THREE.Mesh(makeRoundedBoxGeo(w,46,d,14,5), MAT.base);
  base.position.set(0,23,0);
  root.add(base);

  const body=new THREE.Mesh(makeRoundedBoxGeo(w,h,d,radius,6), MAT.body);
  body.position.set(0,h/2+46,0);
  root.add(body);

  const frame=new THREE.Mesh(makeRoundedBoxGeo(w*0.92,h*0.6,14,12,5), MAT.body2);
  frame.position.set(0,h*0.58,d/2+6);
  root.add(frame);

  const glass=new THREE.Mesh(makeRoundedBoxGeo(w*0.86,h*0.52,10,12,5), MAT.glass);
  glass.position.set(0,h*0.58,d/2+10);
  root.add(glass);

  addPanel(root,0,h+46-140,d/2+16,w*0.6,84);
  addAccentStripe(root,w*0.22,h+46-190,d/2+16,w*0.35,20,accentHex);

  return { root, pickHeight:h+46 };
}
function buildWall3D(wPx,dPx, wallHpx){
  const root=new THREE.Group();
  // thickness appearance: make it a solid wall box
  const geo=new THREE.BoxGeometry(wPx, wallHpx, dPx);
  const mat=new THREE.MeshStandardMaterial({ color:0x334155, roughness:0.92, metalness:0.05 });
  const mesh=new THREE.Mesh(geo, mat);
  mesh.position.set(0, wallHpx/2, 0);
  root.add(mesh);
  return { root, pickHeight: wallHpx };
}
function buildPrefab3D(key, wPx, dPx, hPx, accentHex, kind, customData){
  if(kind==='wall'){
    const wallHpx = mmToPx(customData.wallHeightMm || ROOM.wallHeightMm);
    return buildWall3D(wPx, dPx, wallHpx);
  }
  switch(key){
    case 'bench': return buildBench3D(wPx,dPx,mmToPx(800));
    case 'fridge': return buildFridgeLike3D(wPx,dPx,hPx,accentHex);
    case 'ultra_low_freezer': return buildFridgeLike3D(wPx,dPx,hPx,accentHex);
    case 'incubator': return buildIncubator3D(wPx,dPx,hPx,accentHex);
    case 'centrifuge': return buildCentrifuge3D(wPx,dPx,hPx,accentHex);
    case 'sink': return buildSink3D(wPx,dPx,mmToPx(900),accentHex);
    case 'hood': return buildHood3D(wPx,dPx,hPx,accentHex);
    default: return buildFridgeLike3D(wPx,dPx,hPx,accentHex);
  }
}

/* ========== 3D Engine ========== */
let sc, cam, rend, ctrl;
let objectsGroup, roomGroup3D, groundMesh, dirLight;
const threeMap=new Map();
const pickables=[];
const raycaster=new THREE.Raycaster();
const pointer=new THREE.Vector2();

function is3DVisible(){
  const c3d=document.getElementById('three-container');
  return c3d && c3d.style.display==='block';
}
function get3DSize(){
  const c3d=document.getElementById('three-container');
  return { w:Math.max(1,c3d.clientWidth||0), h:Math.max(1,c3d.clientHeight||0) };
}
function resize3D(){
  if(!rend||!cam) return;
  const {w,h}=get3DSize();
  rend.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  rend.setSize(w,h,false);
  cam.aspect=w/h;
  cam.updateProjectionMatrix();
  updateDebug3D();
}
function init3DIfNeeded(){
  const c3d=document.getElementById('three-container');
  if(sc) return;

  sc=new THREE.Scene();
  sc.background=new THREE.Color(0x0a0f1a);

  const {w,h}=get3DSize();
  cam=new THREE.PerspectiveCamera(45,w/h,1,20000);
  cam.position.set(1000,1000,1000);

  rend=new THREE.WebGLRenderer({ antialias:true, alpha:false });
  rend.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  rend.setSize(w,h,false);
  rend.shadowMap.enabled=true;
  rend.shadowMap.type=THREE.PCFSoftShadowMap;
  c3d.appendChild(rend.domElement);

  ctrl=new THREE.OrbitControls(cam, rend.domElement);
  ctrl.enableDamping=true;
  ctrl.dampingFactor=0.08;
  ctrl.target.set(0,0,0);
  ctrl.update();

  sc.add(new THREE.AmbientLight(0xffffff,0.55));

  dirLight=new THREE.DirectionalLight(0xffffff,0.9);
  dirLight.position.set(1200,1800,900);
  dirLight.castShadow=true;
  dirLight.shadow.mapSize.width=2048;
  dirLight.shadow.mapSize.height=2048;
  dirLight.shadow.camera.near=1;
  dirLight.shadow.camera.far=12000;
  dirLight.shadow.camera.left=-5000;
  dirLight.shadow.camera.right=5000;
  dirLight.shadow.camera.top=5000;
  dirLight.shadow.camera.bottom=-5000;
  sc.add(dirLight);

  const groundGeo=new THREE.PlaneGeometry(12000,12000);
  const groundMat=new THREE.MeshStandardMaterial({ color:0x0b1220, roughness:0.95, metalness:0.0 });
  groundMesh=new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x=-Math.PI/2;
  groundMesh.position.y=0;
  groundMesh.receiveShadow=true;
  sc.add(groundMesh);

  sc.add(new THREE.GridHelper(8000,80,0x334155,0x1e293b));

  roomGroup3D=new THREE.Group();
  sc.add(roomGroup3D);

  objectsGroup=new THREE.Group();
  sc.add(objectsGroup);

  rend.domElement.addEventListener('pointerdown', onPointerDown3D);
}

function buildRoom3D(){
  while(roomGroup3D.children.length) roomGroup3D.remove(roomGroup3D.children[0]);

  const w=mmToPx(ROOM.widthMm), d=mmToPx(ROOM.depthMm);
  const wallH=mmToPx(ROOM.wallHeightMm), t=mmToPx(ROOM.wallThicknessMm);

  const wallMat=new THREE.MeshStandardMaterial({ color:0x111827, roughness:0.9, metalness:0.0 });
  const floorMat=new THREE.MeshStandardMaterial({ color:0x0b1220, roughness:0.95, metalness:0.0 });

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(w,d), floorMat);
  floor.rotation.x=-Math.PI/2;
  floor.receiveShadow=true;
  roomGroup3D.add(floor);

  const wallGeo1=new THREE.BoxGeometry(w,wallH,t);
  const wallGeo2=new THREE.BoxGeometry(t,wallH,d);

  const wallN=new THREE.Mesh(wallGeo1, wallMat); wallN.position.set(0,wallH/2,-d/2);
  const wallS=new THREE.Mesh(wallGeo1, wallMat); wallS.position.set(0,wallH/2,d/2);
  const wallW=new THREE.Mesh(wallGeo2, wallMat); wallW.position.set(-w/2,wallH/2,0);
  const wallE=new THREE.Mesh(wallGeo2, wallMat); wallE.position.set(w/2,wallH/2,0);
  [wallN,wallS,wallW,wallE].forEach(wm=>{ wm.castShadow=true; wm.receiveShadow=true; roomGroup3D.add(wm); });
}

function update3D(){
  if(!sc) return;
  buildRoom3D();

  while(objectsGroup.children.length) objectsGroup.remove(objectsGroup.children[0]);
  threeMap.clear();
  pickables.length=0;

  const rr=getRoomRectPx();
  const cx=rr.x+rr.width/2;
  const cy=rr.y+rr.height/2;

  const groups=layer.getChildren().filter(n=>n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'||n.name()==='wall'));

  groups.forEach(n=>{
    const rect=n.findOne('.main-rect');
    const wPx=rect.width()*n.scaleX();
    const dPx=rect.height()*n.scaleY();

    const kind = n.name();
    const key=n.attrs.customData?.deviceKey || kind;
    const accent=n.attrs.customData?.accent || '#60a5fa';

    // height for devices from catalog; walls use wallHeightMm; zone is flat
    const hPx = (kind==='zone') ? 0 : (kind==='wall' ? mmToPx(n.attrs.customData?.wallHeightMm || ROOM.wallHeightMm) : (n.attrs.customData?.height3dPx || mmToPx(800)));

    const x3d=(n.x()+wPx/2)-cx;
    const z3d=(n.y()+dPx/2)-cy;

    if(kind==='zone'){
      const mat=new THREE.MeshStandardMaterial({ color:0x3b82f6, transparent:true, opacity:0.18, roughness:0.95, metalness:0.0, side:THREE.DoubleSide });
      const mesh=new THREE.Mesh(new THREE.PlaneGeometry(wPx,dPx), mat);
      mesh.rotation.x=-Math.PI/2;
      mesh.position.set(x3d,1,z3d);
      mesh.userData={ konvaId:n._id, kind:'zone' };

      const edges=new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), new THREE.LineBasicMaterial({ color:0x60a5fa, transparent:true, opacity:0.9 }));
      edges.rotation.copy(mesh.rotation);
      edges.position.copy(mesh.position);
      edges.visible=false;

      const root=new THREE.Group();
      root.add(mesh); root.add(edges);
      objectsGroup.add(root);

      threeMap.set(n._id,{ root, pickMesh:mesh, outline:edges, key:'zone', zoneMesh:mesh });
      pickables.push(mesh);
      return;
    }

    const prefab=buildPrefab3D(key,wPx,dPx,hPx,accent,kind,n.attrs.customData||{});
    const root=prefab.root;
    root.position.set(x3d,0,z3d);
    root.rotation.y = -THREE.MathUtils.degToRad(n.rotation());
    root.traverse(obj=>{ if(obj.isMesh){ obj.castShadow=true; obj.receiveShadow=true; }});

    const pickGeo=new THREE.BoxGeometry(wPx, prefab.pickHeight || hPx, dPx);
    const pickMesh=new THREE.Mesh(pickGeo, new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0 }));
    pickMesh.position.set(0,(prefab.pickHeight||hPx)/2,0);
    pickMesh.userData={ konvaId:n._id, kind:kind };
    root.add(pickMesh);

    const outline=new THREE.LineSegments(new THREE.EdgesGeometry(pickGeo), new THREE.LineBasicMaterial({ color:0x93c5fd, transparent:true, opacity:0.95 }));
    outline.position.copy(pickMesh.position);
    outline.visible=false;
    root.add(outline);

    objectsGroup.add(root);
    threeMap.set(n._id,{ root, pickMesh, outline, key, kind });
    pickables.push(pickMesh);
  });

  fitCameraToRoom();
  sync3DSelectionHighlight();
  sync3DConflictHighlight();
  updateDebug3D();
}

function fitCameraToRoom(){
  const maxDim=Math.max(mmToPx(ROOM.widthMm), mmToPx(ROOM.depthMm));
  ctrl.target.set(0,0,0);
  const fov=cam.fov*(Math.PI/180);
  let dist=Math.abs(maxDim/2/Math.tan(fov/2));
  dist*=1.35;
  const dir=new THREE.Vector3(1,1,1).normalize();
  cam.position.copy(dir.multiplyScalar(dist));
  cam.near=Math.max(1, dist/100);
  cam.far=Math.max(20000, dist*10);
  cam.updateProjectionMatrix();
  ctrl.update();
}

function sync3DSelectionHighlight(){
  const sel=new Set(selectedNodes.map(n=>n._id));
  threeMap.forEach((obj,id)=>{
    const selected=sel.has(id);
    if(obj.zoneMesh){
      obj.zoneMesh.material.opacity = selected ? 0.28 : 0.18;
      obj.outline.visible = selected;
      return;
    }
    obj.outline.visible = selected;
  });
}

function sync3DConflictHighlight(){
  threeMap.forEach((obj,id)=>{
    if(obj.kind !== 'device') {
      // wall/zone conflict highlight not implemented yet
      return;
    }
    const isConflict=conflictIds.has(id);
    if(!obj.outline) return;
    if(!isConflict){
      obj.outline.material.color.setHex(0x93c5fd);
      return;
    }
    const hard = collisionPairs.some(p=>p.type==='overlap' && (p.aId===id || p.bId===id));
    obj.outline.material.color.setHex(hard ? 0xef4444 : 0xf59e0b);
    obj.outline.visible = true;
  });
}

function animate3D(){
  if(is3DVisible()){
    requestAnimationFrame(animate3D);
    ctrl.update();
    rend.render(sc, cam);
  }
}

function updateDebug3D(){
  const el=document.getElementById('debug3d');
  if(!el || !is3DVisible()) return;
  const {w,h}=get3DSize();
  el.textContent=`3D: ${w}x${h}\nObjects: ${threeMap.size}\nConflicts: ${collisionPairs.length}\n`;
}

/* 3D picking + info card */
function onPointerDown3D(e){
  if(!is3DVisible() || !cam) return;
  const rect=rend.domElement.getBoundingClientRect();
  pointer.set(((e.clientX-rect.left)/rect.width)*2-1, -(((e.clientY-rect.top)/rect.height)*2-1));
  raycaster.setFromCamera(pointer, cam);

  const hits=raycaster.intersectObjects(pickables,false);
  if(hits.length===0){
    hideInfoCard();
    if(!e.shiftKey){ clearSelection(); layer.draw(); }
    return;
  }
  const id=hits[0].object.userData?.konvaId;
  const node=layer.getChildren().find(n=>n instanceof Konva.Group && n._id===id);
  if(!node) return;

  if(e.shiftKey) toggleSelectNode(node);
  else selectSingleNode(node);

  layer.draw();
  showInfoCardFor(node,{x:e.clientX,y:e.clientY});
}

function getNodeSizeMm(node){
  const r=node.findOne('.main-rect');
  const wPx=r.width()*node.scaleX();
  const dPx=r.height()*node.scaleY();
  const kind=node.name();
  const hPx = (kind==='wall')
    ? mmToPx(node.attrs.customData?.wallHeightMm || ROOM.wallHeightMm)
    : (node.attrs.customData?.height3dPx || 0);
  return { wMm:pxToMm(wPx), dMm:pxToMm(dPx), hMm:pxToMm(hPx) };
}

function showInfoCardFor(node,pt){
  const card=document.getElementById('info-card');
  const name=node.findOne('.title-text')?.text()||'';
  const key=node.attrs.customData?.deviceKey||node.name();
  const size=getNodeSizeMm(node);
  card.innerHTML=`
    <div class="info-title"><div class="info-icon">âŸ²</div><div style="flex:1;"><div style="font-weight:800;">${escapeHtml(name)}</div></div></div>
    <div class="info-row"><div class="info-key">é¡åˆ¥</div><div>${escapeHtml(node.name())}</div></div>
    <div class="info-row"><div class="info-key">Key</div><div>${escapeHtml(key)}</div></div>
    <div class="info-row"><div class="info-key">å°ºå¯¸</div><div>${size.wMm}Ã—${size.dMm}mm</div></div>
    <div class="info-row"><div class="info-key">é«˜åº¦</div><div>${fmtCm(size.hMm)}</div></div>
  `;
  card.style.display='block';

  const vw=window.innerWidth,vh=window.innerHeight;
  const cw=320,ch=170;
  let left=pt.x+14,top=pt.y+14;
  if(left+cw>vw) left=pt.x-cw-14;
  if(top+ch>vh) top=pt.y-ch-14;
  card.style.left=`${left}px`;
  card.style.top=`${top}px`;
}
function hideInfoCard(){ document.getElementById('info-card').style.display='none'; }

/* ========== Toolbar wiring ========== */
document.getElementById('btn-export-png').onclick=()=>exportImg('png');
document.getElementById('btn-export-pdf').onclick=()=>exportImg('pdf');
document.getElementById('btn-delete').onclick=()=>deleteSelected();
document.getElementById('btn-export-json').onclick=()=>exportDesignJSON();
document.getElementById('btn-import-json').onclick=()=>triggerImportJSON();
document.getElementById('btn-reset').onclick=()=>resetDesign(true);
document.getElementById('btn-grid').onclick=()=>toggleGrid();
document.getElementById('btn-snap').onclick=()=>toggleSnap();

document.getElementById('toggle-3d').onclick=()=>{
  const btn=document.getElementById('toggle-3d');
  const c2d=document.getElementById('container');
  const c3d=document.getElementById('three-container');
  const debug=document.getElementById('debug3d');

  const opening=(c3d.style.display===''||c3d.style.display==='none');
  if(opening){
    // when 3D open, exit placement mode to avoid confusion
    if(placementMode) setPlacementMode(null);

    c3d.style.display='block';
    c2d.style.display='none';
    debug.style.display='block';
    btn.innerText='è¿”å› 2D';
    requestAnimationFrame(()=>{
      init3DIfNeeded();
      resize3D();
      update3D();
      animate3D();
    });
  }else{
    hideInfoCard();
    c3d.style.display='none';
    c2d.style.display='block';
    debug.style.display='none';
    btn.innerText='æŸ¥çœ‹ 3D é è¦½';
  }
};

/* ========== Resize ========== */
window.addEventListener('resize',()=>{
  stage.width(window.innerWidth-640);
  stage.height(window.innerHeight);
  drawGrid();
  drawRoomBoundary2D();
  layer.draw();
  if(warningLayer) warningLayer.draw();
  if(is3DVisible()) resize3D();
});

/* ========== Boot ========== */
setupTabs();
renderDevices();
renderWalls();
drawGrid();
drawRoomBoundary2D();
initWarningLayer();
renderInspector();
tryLoadFromLocalStorage();
scheduleCollisionCheck();
</script>
</body>
</html>
