<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LabCAD Web Pro - 實驗室規劃系統</title>

  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root{
      --bg-dark:#0f172a; --bg-sidebar:#1e293b; --primary:#3b82f6; --accent:#10b981; --danger:#ef4444; --border:#334155; --text:#f1f5f9;
    }
    body{ margin:0; font-family:'Segoe UI',system-ui; background:var(--bg-dark); color:var(--text); overflow:hidden; }
    .app{ display:grid; grid-template-columns:280px 1fr 300px; height:100vh; }
    .sidebar{ background:var(--bg-sidebar); border-right:1px solid var(--border); display:flex; flex-direction:column; }
    .sidebar-header{ padding:20px; background:#111827; font-weight:bold; border-bottom:1px solid var(--border); }
    .tool-section{ padding:15px; border-bottom:1px solid var(--border); }
    .item{ background:#334155; padding:10px; border-radius:6px; cursor:pointer; text-align:center; font-size:.8rem; margin-bottom:8px; }
    .item:hover{ background:#475569; border:1px solid var(--primary); }
    .canvas-area{ position:relative; background:#f1f5f9; }
    #container,#three-container{ width:100%; height:100%; }
    #three-container{ position:absolute; top:0; left:0; display:none; z-index:60; background:#0a0f1a; }

    .toolbar{
      position:absolute; top:20px; left:50%; transform:translateX(-50%);
      background:rgba(30,41,59,.95); padding:8px 16px; border-radius:50px;
      display:flex; gap:12px; z-index:100; border:1px solid var(--border);
      align-items:center;
    }
    .tool-btn{ background:none; border:none; color:#cbd5e1; cursor:pointer; display:flex; align-items:center; }
    .tool-btn:hover{ color:#fff; }
    .tool-divider{ width:1px; height:18px; background:rgba(148,163,184,.35); margin:0 2px; }

    .inspector{ background:#1e293b; border-left:1px solid var(--border); padding:20px; color:#cbd5e1; overflow:auto; }
    .prop-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:15px; }
    .prop-group{ display:flex; flex-direction:column; gap:4px; }
    .prop-label{ font-size:.7rem; color:#94a3b8; text-transform:uppercase; }
    input{ background:#0f172a; border:1px solid #334155; color:#fff; padding:8px; border-radius:4px; font-size:.9rem; }

    .btn-action{
      color:#fff; border:none; padding:10px; border-radius:6px; cursor:pointer; font-weight:bold;
      width:100%; margin-top:15px; display:flex; align-items:center; justify-content:center; gap:5px;
    }

    #debug3d{
      position:absolute; right:10px; bottom:10px; z-index:200;
      background:rgba(15,23,42,.85); color:#e2e8f0; font-size:12px;
      padding:8px 10px; border:1px solid rgba(148,163,184,.35);
      border-radius:8px; display:none; white-space:pre;
    }

    #toast{
      position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(15,23,42,.9); color:#e2e8f0; font-size:13px;
      padding:8px 12px; border-radius:10px; border:1px solid rgba(148,163,184,.25);
      z-index:300; display:none;
    }

    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      background:rgba(148,163,184,.12);
      border:1px solid rgba(148,163,184,.25);
      color:#e2e8f0; font-size:12px;
      user-select:none;
    }
    .toggle{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px; border-radius:8px;
      border:1px solid rgba(148,163,184,.2);
      background:rgba(15,23,42,.35);
      margin-top:10px;
    }
    .toggle input{ width:auto; }
    .align-grid{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      gap:8px;
      margin-top:10px;
    }
    .small-btn{
      width:100%;
      background:#0f172a;
      border:1px solid rgba(148,163,184,.25);
      color:#e2e8f0;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:12px;
    }
    .small-btn:hover{ border-color: rgba(59,130,246,.7); }
  </style>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="sidebar-header">LabCAD Web Pro</div>
    <div class="tool-section">
      <div class="item" onclick="addZone('新規劃區域')">新增區域</div>
    </div>
    <div class="tool-section">
      <div class="item" onclick="addDevice('實驗桌', 120, 60, 80, '#3b82f6')">實驗桌</div>
      <div class="item" onclick="addDevice('排煙櫃', 100, 80, 200, '#ef4444')">排煙櫃</div>
    </div>
    <div style="margin-top:auto; padding:20px;">
      <button class="btn-action" style="background:var(--accent);" id="toggle-3d" onclick="toggle3D()">查看 3D 預覽</button>
    </div>
  </aside>

  <main class="canvas-area">
    <div class="toolbar" title="工具列">
      <button class="tool-btn" onclick="exportImg('png')" title="匯出 PNG"><i data-lucide="image"></i></button>
      <button class="tool-btn" onclick="exportImg('pdf')" title="匯出 PDF"><i data-lucide="file-text"></i></button>
      <button class="tool-btn" onclick="deleteSelected()" title="刪除選取"><i data-lucide="trash-2"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" onclick="exportDesignJSON()" title="匯出設計 JSON"><i data-lucide="download"></i></button>
      <button class="tool-btn" onclick="triggerImportJSON()" title="匯入設計 JSON"><i data-lucide="upload"></i></button>
      <input id="import-json-input" type="file" accept="application/json" style="display:none" />
      <button class="tool-btn" onclick="resetDesign(true)" title="重置 / 清空"><i data-lucide="rotate-ccw"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" onclick="toggleGrid()" title="顯示/隱藏格線"><i data-lucide="grid-3x3"></i></button>
      <button class="tool-btn" onclick="toggleSnap()" title="吸附格線"><i data-lucide="magnet"></i></button>
    </div>

    <div id="container"></div>
    <div id="three-container"></div>
    <div id="debug3d"></div>
    <div id="toast"></div>
  </main>

  <aside class="inspector">
    <h3 id="ins-title">屬性</h3>
    <div id="inspector-content">請選擇物件</div>
  </aside>
</div>

<script>
/* ===========================
 * Helpers / UI
 * =========================== */
lucide.createIcons();

function toast(msg, ms = 1200){
  const el = document.getElementById('toast');
  if(!el) return;
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(el._t);
  el._t = setTimeout(() => el.style.display = 'none', ms);
}

function safeInt(v, fallback=0){
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
}

/* ===========================
 * Konva 2D
 * =========================== */
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth - 580,
  height: window.innerHeight
});

const gridLayer = new Konva.Layer();
const layer = new Konva.Layer();
stage.add(gridLayer);
stage.add(layer);

const tr = new Konva.Transformer({ keepRatio: false });
layer.add(tr);

let selectedNodes = [];
let selectedNode = null;

/* ---- Grid / Snap ---- */
const GRID_SIZE = 10;
let gridVisible = true;
let snapEnabled = true;

function toggleGrid(){
  gridVisible = !gridVisible;
  drawGrid();
  toast(gridVisible ? '格線：顯示' : '格線：隱藏');
}

function toggleSnap(){
  snapEnabled = !snapEnabled;
  toast(snapEnabled ? '吸附：開啟' : '吸附：關閉');
}

function snap(v){ return Math.round(v / GRID_SIZE) * GRID_SIZE; }

function drawGrid(){
  gridLayer.destroyChildren();
  if(!gridVisible){ gridLayer.draw(); return; }

  const w = stage.width();
  const h = stage.height();

  for(let x=0; x<=w; x+=GRID_SIZE){
    gridLayer.add(new Konva.Line({ points:[x,0,x,h], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  }
  for(let y=0; y<=h; y+=GRID_SIZE){
    gridLayer.add(new Konva.Line({ points:[0,y,w,y], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  }
  gridLayer.draw();
}

/* ---- selection rectangle ---- */
let selecting = false;
let selectionRect;
let startPos = null;

function initSelectionRect(){
  selectionRect = new Konva.Rect({
    x: 0, y: 0, width: 0, height: 0,
    fill: 'rgba(59,130,246,0.12)',
    stroke: 'rgba(59,130,246,0.9)',
    strokeWidth: 1,
    visible: false,
    listening: false
  });
  layer.add(selectionRect);
}
initSelectionRect();

/* ===========================
 * Nodes CRUD
 * =========================== */
function addZone(name){ createNode('zone', name, 300, 200, 0, 'rgba(59, 130, 246, 0.1)', '#3b82f6'); }
function addDevice(name, w, h, z, color){ createNode('device', name, w, h, z, color, '#1e293b'); }

function createNode(type, name, w, h, z, fill, stroke){
  const group = new Konva.Group({ x: 100, y: 100, draggable: true, name: type, customData: { height3d: z } });

  const rect = new Konva.Rect({ width: w, height: h, fill, stroke, name: 'main-rect', dash: type === 'zone' ? [10,5] : [] });
  const title = new Konva.Text({ text: name, fontSize: 14, fill: stroke, padding: 8, name: 'title-text' });
  const dim = new Konva.Text({ text: '', fontSize: 10, fill: stroke, name: 'dim-label' });

  group.add(rect, title, dim);
  updateUI(group);

  group.on('dragmove', () => {
    if(snapEnabled) group.position({ x: snap(group.x()), y: snap(group.y()) });
    updateUI(group);
    scheduleAutosave();
  });
  group.on('dragend', () => scheduleAutosave());

  group.on('transform', () => { updateUI(group); scheduleAutosave(); });
  group.on('transformend', () => {
    if(snapEnabled) normalizeGroupToGrid(group);
    scheduleAutosave();
    if(is3DVisible()) update3D();
  });

  group.on('click tap', (e) => {
    e.cancelBubble = true;
    const multi = e.evt && e.evt.shiftKey;
    if(multi) toggleSelectNode(group);
    else selectSingleNode(group);
  });

  layer.add(group);
  if(type === 'zone') group.moveToBottom();

  selectSingleNode(group);
  layer.draw();

  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function normalizeGroupToGrid(group){
  group.x(snap(group.x()));
  group.y(snap(group.y()));

  const rect = group.findOne('.main-rect');
  const absW = rect.width() * group.scaleX();
  const absH = rect.height() * group.scaleY();

  const targetW = Math.max(GRID_SIZE, snap(absW));
  const targetH = Math.max(GRID_SIZE, snap(absH));

  group.scaleX(targetW / rect.width());
  group.scaleY(targetH / rect.height());

  layer.draw();
}

function updateUI(group){
  const rect = group.findOne('.main-rect');
  const dim = group.findOne('.dim-label');
  const w = Math.round(rect.width() * group.scaleX());
  const h = Math.round(rect.height() * group.scaleY());
  dim.text(`${w} x ${h}`);
  dim.x(rect.width() - dim.width() - 5);
  dim.y(rect.height() - 15);

  if(selectedNodes.includes(group)) renderInspector();
}

/* ===========================
 * Selection model
 * =========================== */
function applyTransformer(){
  tr.nodes(selectedNodes);
  layer.draw();
  sync3DSelectionHighlight();
}

function clearSelection(){
  selectedNodes = [];
  selectedNode = null;
  applyTransformer();
  document.getElementById('inspector-content').innerText = '請選擇物件';
}

function selectSingleNode(node){
  selectedNodes = [node];
  selectedNode = node;
  applyTransformer();
  renderInspector();
}

function toggleSelectNode(node){
  const idx = selectedNodes.indexOf(node);
  if(idx >= 0) selectedNodes.splice(idx, 1);
  else selectedNodes.push(node);

  selectedNode = selectedNodes.length === 1 ? selectedNodes[0] : null;

  applyTransformer();
  renderInspector();
}

stage.on('click tap', (e) => {
  if(e.target === stage){
    clearSelection();
    layer.draw();
    if(is3DVisible()) update3D();
  }
});

stage.on('mousedown touchstart', (e) => {
  if(is3DVisible()) return;
  if(e.target !== stage) return;
  if(e.evt && (e.evt.button !== undefined) && e.evt.button !== 0) return;

  selecting = true;
  startPos = stage.getPointerPosition();
  selectionRect.visible(true);
  selectionRect.position(startPos);
  selectionRect.size({ width: 0, height: 0 });
  layer.draw();
});

stage.on('mousemove touchmove', () => {
  if(!selecting) return;
  const pos = stage.getPointerPosition();
  if(!pos) return;

  const x = Math.min(startPos.x, pos.x);
  const y = Math.min(startPos.y, pos.y);
  const w = Math.abs(pos.x - startPos.x);
  const h = Math.abs(pos.y - startPos.y);

  selectionRect.setAttrs({ x, y, width: w, height: h });
  layer.batchDraw();
});

stage.on('mouseup touchend', (e) => {
  if(!selecting) return;
  selecting = false;

  selectionRect.visible(false);
  layer.draw();

  const box = selectionRect.getClientRect();
  const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));
  const additive = e.evt && e.evt.shiftKey;

  const hits = groups.filter(g => Konva.Util.haveIntersection(box, g.getClientRect()));
  if(!additive) selectedNodes = [];
  hits.forEach(g => { if(!selectedNodes.includes(g)) selectedNodes.push(g); });

  selectedNode = selectedNodes.length === 1 ? selectedNodes[0] : null;
  applyTransformer();
  renderInspector();
  if(is3DVisible()) update3D();
});

/* ===========================
 * Inspector
 * =========================== */
function renderInspector(){
  const container = document.getElementById('inspector-content');

  if(selectedNodes.length === 0){
    container.innerText = '請選擇物件';
    return;
  }

  if(selectedNodes.length > 1){
    container.innerHTML = `
      <div class="chip">已選取：${selectedNodes.length} 個物件</div>

      <div class="toggle">
        <div>
          <div class="prop-label">格線</div>
          <div style="font-size:12px;color:#94a3b8;">格距：${GRID_SIZE}px</div>
        </div>
        <input type="checkbox" ${gridVisible ? 'checked' : ''} onchange="toggleGrid()">
      </div>

      <div class="toggle">
        <div>
          <div class="prop-label">吸附</div>
          <div style="font-size:12px;color:#94a3b8;">拖曳/縮放吸附格線</div>
        </div>
        <input type="checkbox" ${snapEnabled ? 'checked' : ''} onchange="toggleSnap()">
      </div>

      <div style="margin-top:14px;">
        <div class="prop-label">對齊</div>
        <div class="align-grid">
          <button class="small-btn" onclick="align('left')">左</button>
          <button class="small-btn" onclick="align('centerX')">中</button>
          <button class="small-btn" onclick="align('right')">右</button>

          <button class="small-btn" onclick="align('top')">上</button>
          <button class="small-btn" onclick="align('centerY')">中</button>
          <button class="small-btn" onclick="align('bottom')">下</button>
        </div>
      </div>

      <div style="margin-top:14px;">
        <div class="prop-label">分佈</div>
        <div class="align-grid">
          <button class="small-btn" onclick="distribute('h')">水平等距</button>
          <button class="small-btn" onclick="distribute('v')">垂直等距</button>
          <button class="small-btn" onclick="normalizeSelectionToGrid()">吸附全部</button>
        </div>
      </div>

      <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除選取 (${selectedNodes.length})</button>
    `;
    return;
  }

  const n = selectedNodes[0];
  const r = n.findOne('.main-rect');
  const w = Math.round(r.width() * n.scaleX());
  const h = Math.round(r.height() * n.scaleY());

  container.innerHTML = `
    <div class="chip">已選取：1 個物件（Shift 可多選）</div>

    <div class="toggle">
      <div>
        <div class="prop-label">格線</div>
        <div style="font-size:12px;color:#94a3b8;">格距：${GRID_SIZE}px</div>
      </div>
      <input type="checkbox" ${gridVisible ? 'checked' : ''} onchange="toggleGrid()">
    </div>

    <div class="toggle">
      <div>
        <div class="prop-label">吸附</div>
        <div style="font-size:12px;color:#94a3b8;">拖曳/縮放吸附格線</div>
      </div>
      <input type="checkbox" ${snapEnabled ? 'checked' : ''} onchange="toggleSnap()">
    </div>

    <div class="prop-row" style="margin-top:12px;">
      <label class="prop-label">名稱</label>
      <input type="text" value="${n.findOne('.title-text').text()}" oninput="updateProp('name', this.value)">
    </div>

    <div class="prop-grid">
      <div class="prop-group"><label class="prop-label">X</label><input type="number" value="${Math.round(n.x())}" oninput="updateProp('x', this.value)"></div>
      <div class="prop-group"><label class="prop-label">Y</label><input type="number" value="${Math.round(n.y())}" oninput="updateProp('y', this.value)"></div>
      <div class="prop-group"><label class="prop-label">W</label><input type="number" value="${w}" oninput="updateProp('w', this.value)"></div>
      <div class="prop-group"><label class="prop-label">H</label><input type="number" value="${h}" oninput="updateProp('h', this.value)"></div>
      <div class="prop-group"><label class="prop-label">旋轉</label><input type="number" value="${Math.round(n.rotation())}" oninput="updateProp('rot', this.value)"></div>
      <div class="prop-group"><label class="prop-label">高度</label><input type="number" value="${n.attrs.customData?.height3d || 0}" oninput="updateProp('z', this.value)"></div>
    </div>

    <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除物件</button>
  `;
}

function updateProp(p, v){
  if(selectedNodes.length !== 1) return;
  const node = selectedNodes[0];

  if(p === 'name') node.findOne('.title-text').text(v);
  if(p === 'x') node.x(snapEnabled ? snap(safeInt(v)) : safeInt(v));
  if(p === 'y') node.y(snapEnabled ? snap(safeInt(v)) : safeInt(v));

  if(p === 'w'){
    const rect = node.findOne('.main-rect');
    const baseW = rect.width();
    let targetW = Math.max(1, safeInt(v, baseW));
    if(snapEnabled) targetW = Math.max(GRID_SIZE, snap(targetW));
    node.scaleX(targetW / baseW);
  }
  if(p === 'h'){
    const rect = node.findOne('.main-rect');
    const baseH = rect.height();
    let targetH = Math.max(1, safeInt(v, baseH));
    if(snapEnabled) targetH = Math.max(GRID_SIZE, snap(targetH));
    node.scaleY(targetH / baseH);
  }

  if(p === 'rot') node.rotation(safeInt(v));
  if(p === 'z') node.attrs.customData.height3d = safeInt(v);

  updateUI(node);
  layer.draw();

  scheduleAutosave();
  if(is3DVisible()) update3D();
}

/* ===========================
 * Align / Distribute
 * =========================== */
function getBounds(node){ return node.getClientRect({ skipTransform: false }); }

function align(mode){
  if(selectedNodes.length < 2) return;

  const bounds = selectedNodes.map(getBounds);
  const minX = Math.min(...bounds.map(b => b.x));
  const maxX = Math.max(...bounds.map(b => b.x + b.width));
  const minY = Math.min(...bounds.map(b => b.y));
  const maxY = Math.max(...bounds.map(b => b.y + b.height));
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  selectedNodes.forEach((node, i) => {
    const b = bounds[i];
    if(mode === 'left') node.x(node.x() + (minX - b.x));
    if(mode === 'right') node.x(node.x() + (maxX - (b.x + b.width)));
    if(mode === 'centerX') node.x(node.x() + (centerX - (b.x + b.width/2)));

    if(mode === 'top') node.y(node.y() + (minY - b.y));
    if(mode === 'bottom') node.y(node.y() + (maxY - (b.y + b.height)));
    if(mode === 'centerY') node.y(node.y() + (centerY - (b.y + b.height/2)));

    if(snapEnabled){ node.x(snap(node.x())); node.y(snap(node.y())); }
    updateUI(node);
  });

  layer.draw();
  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function distribute(axis){
  if(selectedNodes.length < 3) return;

  const nodes = [...selectedNodes];
  if(axis === 'h') nodes.sort((a,b) => getBounds(a).x - getBounds(b).x);
  else nodes.sort((a,b) => getBounds(a).y - getBounds(b).y);

  const firstB = getBounds(nodes[0]);
  const lastB  = getBounds(nodes[nodes.length - 1]);

  if(axis === 'h'){
    const totalWidth = nodes.reduce((sum, n) => sum + getBounds(n).width, 0);
    const span = (lastB.x + lastB.width) - firstB.x;
    const gap = (span - totalWidth) / (nodes.length - 1);

    let cursor = firstB.x;
    nodes.forEach((n, idx) => {
      const b = getBounds(n);
      if(idx === 0) { cursor = firstB.x + b.width + gap; return; }
      if(idx === nodes.length - 1) return;

      n.x(n.x() + (cursor - b.x));
      if(snapEnabled) n.x(snap(n.x()));
      updateUI(n);
      cursor += b.width + gap;
    });
  }else{
    const totalHeight = nodes.reduce((sum, n) => sum + getBounds(n).height, 0);
    const span = (lastB.y + lastB.height) - firstB.y;
    const gap = (span - totalHeight) / (nodes.length - 1);

    let cursor = firstB.y;
    nodes.forEach((n, idx) => {
      const b = getBounds(n);
      if(idx === 0) { cursor = firstB.y + b.height + gap; return; }
      if(idx === nodes.length - 1) return;

      n.y(n.y() + (cursor - b.y));
      if(snapEnabled) n.y(snap(n.y()));
      updateUI(n);
      cursor += b.height + gap;
    });
  }

  layer.draw();
  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function normalizeSelectionToGrid(){
  selectedNodes.forEach(n => normalizeGroupToGrid(n));
  layer.draw();
  scheduleAutosave();
  if(is3DVisible()) update3D();
  toast('已吸附到格線');
}

/* ===========================
 * Delete / Export
 * =========================== */
function deleteSelected(){
  if(selectedNodes.length === 0) return;

  selectedNodes.forEach(n => n.destroy());
  selectedNodes = [];
  selectedNode = null;
  tr.nodes([]);
  document.getElementById('inspector-content').innerText = '請選擇物件';
  layer.draw();

  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function exportImg(f){
  tr.nodes([]);
  layer.draw();

  if(f === 'png'){
    const l = document.createElement('a');
    l.download = 'lab.png';
    l.href = stage.toDataURL();
    l.click();
  }else{
    const doc = new jspdf.jsPDF('l', 'px', [stage.width(), stage.height()]);
    doc.addImage(stage.toDataURL(), 'PNG', 0, 0, stage.width(), stage.height());
    doc.save('lab.pdf');
  }
}

/* ===========================
 * Stage 1: Save/Load
 * =========================== */
const STORAGE_KEY = 'labcad_design_v1';
let autosaveTimer = null;

function scheduleAutosave(){
  clearTimeout(autosaveTimer);
  autosaveTimer = setTimeout(() => saveDesignToLocalStorage(), 150);
}

function serializeNode(group){
  const r = group.findOne('.main-rect');
  const title = group.findOne('.title-text');
  const w = r.width() * group.scaleX();
  const h = r.height() * group.scaleY();

  return {
    type: group.name(),
    name: title ? title.text() : '',
    x: group.x(),
    y: group.y(),
    w, h,
    rot: group.rotation(),
    fill: r.fill(),
    stroke: r.stroke(),
    dash: r.dash(),
    height3d: group.attrs.customData?.height3d || 0
  };
}

function getDesignJSON(){
  const nodes = layer.getChildren()
    .filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'))
    .map(serializeNode);

  return {
    version: 3,
    savedAt: new Date().toISOString(),
    stage: { width: stage.width(), height: stage.height() },
    ui: { gridVisible, snapEnabled, gridSize: GRID_SIZE },
    nodes
  };
}

function saveDesignToLocalStorage(){
  try{
    const design = getDesignJSON();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(design));
  }catch(err){
    console.error(err);
    toast('自動保存失敗（localStorage）');
  }
}

function resetDesign(alsoClearLocalStorage=false){
  const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));
  groups.forEach(g => g.destroy());
  selectionRect.visible(false);

  selectedNodes = [];
  selectedNode = null;
  tr.nodes([]);
  document.getElementById('inspector-content').innerText = '請選擇物件';
  layer.draw();

  if(alsoClearLocalStorage){
    localStorage.removeItem(STORAGE_KEY);
    toast('已清空設計');
  }else{
    scheduleAutosave();
  }

  if(is3DVisible()) update3D();
}

function loadDesignFromObject(design){
  if(!design || !Array.isArray(design.nodes)) throw new Error('Invalid design format');

  resetDesign(false);

  if(design.ui){
    gridVisible = design.ui.gridVisible ?? gridVisible;
    snapEnabled = design.ui.snapEnabled ?? snapEnabled;
  }

  design.nodes.forEach(n => {
    const type = n.type === 'zone' ? 'zone' : 'device';
    const stroke = n.stroke || (type==='zone' ? '#3b82f6' : '#1e293b');
    const dash = Array.isArray(n.dash) ? n.dash : (type==='zone' ? [10,5] : []);
    const fill = n.fill || (type==='zone' ? 'rgba(59, 130, 246, 0.1)' : '#3b82f6');

    const group = new Konva.Group({ x: Number(n.x) || 0, y: Number(n.y) || 0, draggable: true, name: type, customData: { height3d: safeInt(n.height3d, 0) } });
    const rect = new Konva.Rect({ width: Math.max(1, Number(n.w) || 10), height: Math.max(1, Number(n.h) || 10), fill, stroke, name: 'main-rect', dash });
    const title = new Konva.Text({ text: n.name || '', fontSize: 14, fill: stroke, padding: 8, name: 'title-text' });
    const dim = new Konva.Text({ text: '', fontSize: 10, fill: stroke, name: 'dim-label' });

    group.rotation(Number(n.rot) || 0);
    group.add(rect, title, dim);
    updateUI(group);

    group.on('dragmove', () => {
      if(snapEnabled) group.position({ x: snap(group.x()), y: snap(group.y()) });
      updateUI(group);
      scheduleAutosave();
    });
    group.on('dragend', () => scheduleAutosave());
    group.on('transform', () => { updateUI(group); scheduleAutosave(); });
    group.on('transformend', () => {
      if(snapEnabled) normalizeGroupToGrid(group);
      scheduleAutosave();
      if(is3DVisible()) update3D();
    });

    group.on('click tap', (e) => {
      e.cancelBubble = true;
      const multi = e.evt && e.evt.shiftKey;
      if(multi) toggleSelectNode(group);
      else selectSingleNode(group);
    });

    layer.add(group);
    if(type === 'zone') group.moveToBottom();
  });

  drawGrid();
  layer.draw();
  scheduleAutosave();
  if(is3DVisible()) update3D();

  toast('已載入設計');
}

function tryLoadFromLocalStorage(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{
    const design = JSON.parse(raw);
    loadDesignFromObject(design);
    toast('已從自動保存載入');
  }catch(err){
    console.warn('Failed to load autosave:', err);
  }
}

function downloadText(filename, text, mime='application/json'){
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function exportDesignJSON(){
  const design = getDesignJSON();
  downloadText('labcad-design.json', JSON.stringify(design, null, 2));
  toast('已匯出 JSON');
}

function triggerImportJSON(){
  document.getElementById('import-json-input').click();
}

document.getElementById('import-json-input').addEventListener('change', (e) => {
  const file = e.target.files && e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    try{
      const design = JSON.parse(reader.result);
      loadDesignFromObject(design);
      toast('已匯入 JSON');
    }catch(err){
      console.error(err);
      toast('匯入失敗：JSON 格式不正確');
    }finally{
      e.target.value = '';
    }
  };
  reader.readAsText(file);
});

/* ===========================
 * 3D Engine (Stage 3: shadows + highlight)
 * =========================== */
let sc, cam, rend, ctrl;
let objectsGroup;
let groundMesh;
let dirLight;

/**
 * 3D objects map
 * key: nodeId (Konva._id)
 * val: { root, mesh, edges, baseMaterial, highlightMaterial }
 */
const threeMap = new Map();

function is3DVisible(){
  const c3d = document.getElementById('three-container');
  return c3d && c3d.style.display === 'block';
}

function get3DSize(){
  const c3d = document.getElementById('three-container');
  const w = Math.max(1, c3d.clientWidth || 0);
  const h = Math.max(1, c3d.clientHeight || 0);
  return { w, h };
}

function resize3D(){
  if(!rend || !cam) return;
  const { w, h } = get3DSize();
  rend.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  rend.setSize(w, h, false);
  cam.aspect = w / h;
  cam.updateProjectionMatrix();
  updateDebug3D();
}

function init3DIfNeeded(){
  const c3d = document.getElementById('three-container');
  if(sc) return;

  sc = new THREE.Scene();
  sc.background = new THREE.Color(0x0a0f1a);

  const { w, h } = get3DSize();
  cam = new THREE.PerspectiveCamera(45, w / h, 1, 10000);
  cam.position.set(1000, 1000, 1000);

  rend = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  rend.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  rend.setSize(w, h, false);
  rend.shadowMap.enabled = true;
  rend.shadowMap.type = THREE.PCFSoftShadowMap;
  c3d.appendChild(rend.domElement);

  ctrl = new THREE.OrbitControls(cam, rend.domElement);
  ctrl.enableDamping = true;
  ctrl.dampingFactor = 0.08;
  ctrl.target.set(0, 0, 0);
  ctrl.update();

  // Lights
  sc.add(new THREE.AmbientLight(0xffffff, 0.55));

  dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
  dirLight.position.set(1200, 1800, 900);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 6000;
  dirLight.shadow.camera.left = -2500;
  dirLight.shadow.camera.right = 2500;
  dirLight.shadow.camera.top = 2500;
  dirLight.shadow.camera.bottom = -2500;
  sc.add(dirLight);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(8000, 8000);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.95, metalness: 0.0 });
  groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI / 2;
  groundMesh.position.y = 0;
  groundMesh.receiveShadow = true;
  sc.add(groundMesh);

  // Helpers
  sc.add(new THREE.GridHelper(5000, 50, 0x334155, 0x1e293b));
  sc.add(new THREE.AxesHelper(200));

  objectsGroup = new THREE.Group();
  objectsGroup.name = 'objectsGroup';
  sc.add(objectsGroup);

  updateDebug3D();
}

function toggle3D(){
  const btn = document.getElementById('toggle-3d');
  const c2d = document.getElementById('container');
  const c3d = document.getElementById('three-container');
  const debug = document.getElementById('debug3d');

  const opening = (c3d.style.display === 'none' || c3d.style.display === '');

  if(opening){
    c3d.style.display = 'block';
    c2d.style.display = 'none';
    btn.innerText = '返回 2D';
    if(debug) debug.style.display = 'block';

    requestAnimationFrame(() => {
      init3DIfNeeded();
      resize3D();
      update3D();
      animate3D();
    });
  }else{
    c3d.style.display = 'none';
    c2d.style.display = 'block';
    btn.innerText = '查看 3D 預覽';
    if(debug) debug.style.display = 'none';
  }
}

function disposeObject(obj){
  if(!obj) return;
  if(obj.geometry) obj.geometry.dispose();
  if(obj.material){
    if(Array.isArray(obj.material)) obj.material.forEach(m => m && m.dispose && m.dispose());
    else if(obj.material.dispose) obj.material.dispose();
  }
}

function clearObjectsGroup(){
  if(!objectsGroup) return;
  for(let i = objectsGroup.children.length - 1; i >= 0; i--){
    const child = objectsGroup.children[i];
    child.traverse?.(n => { if(n.isMesh) disposeObject(n); });
    objectsGroup.remove(child);
  }
  threeMap.clear();
}

/* Build 3D objects and keep mapping for highlight */
function update3D(){
  if(!sc) return;

  clearObjectsGroup();

  const groups = layer.getChildren()
    .filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));

  groups.forEach(n => {
    const r = n.findOne('.main-rect');
    const w = r.width() * n.scaleX();
    const d = r.height() * n.scaleY();
    const x = (n.x() + w/2) - stage.width()/2;
    const z = (n.y() + d/2) - stage.height()/2;

    const id = n._id;

    if(n.name() === 'device'){
      const h = n.attrs.customData?.height3d || 100;

      const baseMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(r.fill()),
        roughness: 0.6,
        metalness: 0.05
      });

      const hiMat = baseMat.clone();
      hiMat.emissive = new THREE.Color(0x1d4ed8);
      hiMat.emissiveIntensity = 0.35;

      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), baseMat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(mesh.geometry),
        new THREE.LineBasicMaterial({ color: 0x93c5fd, transparent: true, opacity: 0.95 })
      );
      edges.visible = false;

      const root = new THREE.Group();
      root.add(mesh);
      root.add(edges);

      root.position.set(x, h/2, z);
      root.rotation.y = -THREE.MathUtils.degToRad(n.rotation());

      objectsGroup.add(root);

      threeMap.set(id, { root, mesh, edges, baseMaterial: baseMat, highlightMaterial: hiMat, type: 'device' });
    }else{
      // zone as slightly raised plane to receive shadow subtly
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x3b82f6,
        transparent: true,
        opacity: 0.18,
        roughness: 0.95,
        metalness: 0.0,
        side: THREE.DoubleSide
      });

      const hiMat = baseMat.clone();
      hiMat.opacity = 0.28;
      hiMat.emissive = new THREE.Color(0x1d4ed8);
      hiMat.emissiveIntensity = 0.18;

      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, d), baseMat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.set(x, 1, z);
      mesh.receiveShadow = true;

      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(mesh.geometry),
        new THREE.LineBasicMaterial({ color: 0x60a5fa, transparent: true, opacity: 0.9 })
      );
      edges.rotation.copy(mesh.rotation);
      edges.position.copy(mesh.position);
      edges.visible = false;

      const root = new THREE.Group();
      root.add(mesh);
      root.add(edges);

      objectsGroup.add(root);

      threeMap.set(id, { root, mesh, edges, baseMaterial: baseMat, highlightMaterial: hiMat, type: 'zone' });
    }
  });

  fitCameraToObjects();
  sync3DSelectionHighlight();
  updateDebug3D();
}

function getSelectedIds(){
  return new Set(selectedNodes.map(n => n._id));
}

/* Highlight in 3D based on current 2D selection */
function sync3DSelectionHighlight(){
  if(!sc || !objectsGroup) return;
  const sel = getSelectedIds();
  threeMap.forEach((obj, id) => {
    const selected = sel.has(id);
    obj.mesh.material = selected ? obj.highlightMaterial : obj.baseMaterial;
    obj.edges.visible = selected;
  });
}

function fitCameraToObjects(){
  if(!objectsGroup || objectsGroup.children.length === 0 || !cam || !ctrl) return;

  const box = new THREE.Box3().setFromObject(objectsGroup);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);

  ctrl.target.copy(center);

  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = cam.fov * (Math.PI / 180);
  let cameraDist = Math.abs(maxDim / 2 / Math.tan(fov / 2));
  cameraDist *= 1.7;

  const dir = new THREE.Vector3(1, 1, 1).normalize();
  cam.position.copy(center.clone().add(dir.multiplyScalar(cameraDist)));
  cam.near = Math.max(1, cameraDist / 100);
  cam.far = Math.max(10000, cameraDist * 12);
  cam.updateProjectionMatrix();

  ctrl.update();
}

function animate3D(){
  if(is3DVisible()){
    requestAnimationFrame(animate3D);
    ctrl.update();
    rend.render(sc, cam);
  }
}

function updateDebug3D(){
  const debug = document.getElementById('debug3d');
  if(!debug || !is3DVisible()) return;
  const { w, h } = get3DSize();
  debug.textContent =
    `3D: ${w} x ${h}\n` +
    `Objects: ${threeMap.size}\n` +
    `Selected: ${selectedNodes.length}\n` +
    `Cam aspect: ${cam ? cam.aspect.toFixed(3) : '-'}\n`;
}

/* ===========================
 * Hotkeys
 * =========================== */
window.addEventListener('keydown', (e) => {
  const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : '';
  const typing = tag === 'input' || tag === 'textarea';

  if(e.key === 'Escape'){
    selectedNodes = [];
    selectedNode = null;
    tr.nodes([]);
    renderInspector();
    layer.draw();
    sync3DSelectionHighlight();
    return;
  }

  if(!typing && (e.key === 'Delete' || e.key === 'Backspace')){
    deleteSelected();
    e.preventDefault();
    return;
  }

  if(!typing && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a'){
    const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));
    selectedNodes = groups;
    selectedNode = selectedNodes.length === 1 ? selectedNodes[0] : null;
    applyTransformer();
    renderInspector();
    e.preventDefault();
  }
});

/* ===========================
 * Resize
 * =========================== */
window.addEventListener('resize', () => {
  stage.width(window.innerWidth - 580);
  stage.height(window.innerHeight);

  drawGrid();
  layer.draw();

  if(is3DVisible()) resize3D();
});

/* ===========================
 * Boot
 * =========================== */
drawGrid();
tryLoadFromLocalStorage();
</script>
</body>
</html>
