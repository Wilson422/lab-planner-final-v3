<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LabCAD Web Pro - 實驗室規劃系統</title>

  <!-- Non-module globals (still OK with module script below) -->
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root{
      --bg-dark:#0f172a; --bg-sidebar:#1e293b; --primary:#3b82f6; --accent:#10b981; --danger:#ef4444; --border:#334155; --text:#f1f5f9;
    }
    body{ margin:0; font-family:'Segoe UI',system-ui; background:var(--bg-dark); color:var(--text); overflow:hidden; }
    .app{ display:grid; grid-template-columns:280px 1fr 320px; height:100vh; }
    .sidebar{ background:var(--bg-sidebar); border-right:1px solid var(--border); display:flex; flex-direction:column; overflow:auto; }
    .sidebar-header{ padding:20px; background:#111827; font-weight:bold; border-bottom:1px solid var(--border); position:sticky; top:0; z-index:2; }
    .tool-section{ padding:15px; border-bottom:1px solid var(--border); }
    .tool-section-title{ font-size:12px; letter-spacing:.08em; color:#94a3b8; text-transform:uppercase; margin-bottom:10px; }
    .item{ background:#334155; padding:10px; border-radius:6px; cursor:pointer; text-align:center; font-size:.8rem; margin-bottom:8px; user-select:none; }
    .item:hover{ background:#475569; border:1px solid var(--primary); }

    .canvas-area{ position:relative; background:#f1f5f9; }
    #container,#three-container{ width:100%; height:100%; }
    #three-container{ position:absolute; top:0; left:0; display:none; z-index:60; background:#0a0f1a; }

    .toolbar{
      position:absolute; top:20px; left:50%; transform:translateX(-50%);
      background:rgba(30,41,59,.95); padding:8px 16px; border-radius:50px;
      display:flex; gap:12px; z-index:100; border:1px solid var(--border);
      align-items:center;
    }
    .tool-btn{ background:none; border:none; color:#cbd5e1; cursor:pointer; display:flex; align-items:center; }
    .tool-btn:hover{ color:#fff; }
    .tool-divider{ width:1px; height:18px; background:rgba(148,163,184,.35); margin:0 2px; }

    .inspector{ background:#1e293b; border-left:1px solid var(--border); padding:20px; color:#cbd5e1; overflow:auto; }
    .prop-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:15px; }
    .prop-group{ display:flex; flex-direction:column; gap:4px; }
    .prop-label{ font-size:.7rem; color:#94a3b8; text-transform:uppercase; }
    input{ background:#0f172a; border:1px solid #334155; color:#fff; padding:8px; border-radius:6px; font-size:.9rem; }

    .btn-action{
      color:#fff; border:none; padding:10px; border-radius:8px; cursor:pointer; font-weight:bold;
      width:100%; margin-top:12px; display:flex; align-items:center; justify-content:center; gap:5px;
    }

    #debug3d{
      position:absolute; right:10px; bottom:10px; z-index:200;
      background:rgba(15,23,42,.85); color:#e2e8f0; font-size:12px;
      padding:8px 10px; border:1px solid rgba(148,163,184,.35);
      border-radius:8px; display:none; white-space:pre;
    }

    #toast{
      position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(15,23,42,.9); color:#e2e8f0; font-size:13px;
      padding:8px 12px; border-radius:10px; border:1px solid rgba(148,163,184,.25);
      z-index:300; display:none;
    }

    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      background:rgba(148,163,184,.12);
      border:1px solid rgba(148,163,184,.25);
      color:#e2e8f0; font-size:12px;
      user-select:none;
    }

    .hint{
      color:#94a3b8; font-size:12px; line-height:1.35; margin-top:10px;
    }

    /* 3D info card */
    #info-card{
      position:absolute;
      min-width: 240px;
      max-width: 320px;
      pointer-events:none;
      z-index: 250;
      display:none;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(96, 165, 250, 0.55);
      border-radius: 14px;
      padding: 12px 14px;
      color: #e2e8f0;
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .info-title{ font-weight:700; font-size:16px; margin-bottom:10px; display:flex; align-items:center; gap:10px; }
    .info-icon{
      width:34px; height:34px; border-radius:10px;
      background: rgba(59,130,246,0.18);
      border: 1px solid rgba(59,130,246,0.45);
      display:flex; align-items:center; justify-content:center;
      color:#93c5fd;
      font-weight:800;
    }
    .info-row{
      display:flex; justify-content:space-between; gap:14px;
      padding:6px 0;
      border-top: 1px solid rgba(148,163,184,0.16);
      font-size:13px;
    }
    .info-row:first-of-type{ border-top:none; }
    .info-key{ color:#94a3b8; }
  </style>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="sidebar-header">LabCAD Web Pro</div>

    <div class="tool-section">
      <div class="tool-section-title">房間</div>
      <div class="item" id="room-settings-btn">房間設定（寬/長/牆高）</div>
    </div>

    <div class="tool-section">
      <div class="tool-section-title">區域</div>
      <div class="item" id="add-zone-btn">新增區域</div>
    </div>

    <div class="tool-section" id="device-catalog">
      <div class="tool-section-title">設備</div>
      <div style="color:#94a3b8;font-size:12px;">載入中...</div>
    </div>

    <div style="margin-top:auto; padding:20px; position:sticky; bottom:0; background:linear-gradient(180deg, rgba(30,41,59,0), rgba(30,41,59,1) 30%);">
      <button class="btn-action" style="background:var(--accent);" id="toggle-3d">查看 3D 預覽</button>
      <div class="hint" style="margin-top:10px;">
        單位：1格=10cm=100mm（格線10px）<br/>
        3D：點選物件可反選到2D（Shift可多選）
      </div>
    </div>
  </aside>

  <main class="canvas-area">
    <div class="toolbar" title="工具列">
      <button class="tool-btn" id="btn-export-png" title="匯出 PNG"><i data-lucide="image"></i></button>
      <button class="tool-btn" id="btn-export-pdf" title="匯出 PDF"><i data-lucide="file-text"></i></button>
      <button class="tool-btn" id="btn-delete" title="刪除選取"><i data-lucide="trash-2"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" id="btn-export-json" title="匯出設計 JSON"><i data-lucide="download"></i></button>
      <button class="tool-btn" id="btn-import-json" title="匯入設計 JSON"><i data-lucide="upload"></i></button>
      <input id="import-json-input" type="file" accept="application/json" style="display:none" />
      <button class="tool-btn" id="btn-reset" title="重置 / 清空"><i data-lucide="rotate-ccw"></i></button>

      <div class="tool-divider"></div>

      <button class="tool-btn" id="btn-grid" title="顯示/隱藏格線"><i data-lucide="grid-3x3"></i></button>
      <button class="tool-btn" id="btn-snap" title="吸附格線"><i data-lucide="magnet"></i></button>
    </div>

    <div id="container"></div>
    <div id="three-container"></div>
    <div id="debug3d"></div>
    <div id="toast"></div>
    <div id="info-card"></div>
  </main>

  <aside class="inspector">
    <h3 id="ins-title">屬性</h3>
    <div id="inspector-content">請選擇物件</div>
  </aside>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.128.0/build/three.module.js?module";
import { OrbitControls } from "https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js?module";
import { RoundedBoxGeometry } from "https://unpkg.com/three@0.128.0/examples/jsm/geometries/RoundedBoxGeometry.js?module";

/* ===========================
 * Globals (non-module libs)
 * =========================== */
window.lucide?.createIcons?.();

/* ===========================
 * Helpers / UI
 * =========================== */
function toast(msg, ms = 1200){
  const el = document.getElementById('toast');
  if(!el) return;
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(el._t);
  el._t = setTimeout(() => el.style.display = 'none', ms);
}
function safeInt(v, fallback=0){
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
}
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

/* ===========================
 * Units
 * =========================== */
const GRID_PX = 10;
const MM_PER_GRID = 100;
const MM_PER_PX = MM_PER_GRID / GRID_PX;
function pxToMm(px){ return Math.round(px * MM_PER_PX); }
function mmToPx(mm){ return mm / MM_PER_PX; }
function mmToCm(mm){ return (mm / 10); }
function fmtMm(mm){ return `${Math.round(mm)}mm`; }
function fmtCm(mm){ return `${Math.round(mmToCm(mm))}cm`; }

/* ===========================
 * Room
 * =========================== */
const ROOM = { widthMm: 6000, depthMm: 4000, wallHeightMm: 2800, wallThicknessMm: 100 };

/* ===========================
 * Device Catalog
 * =========================== */
const DEVICE_CATALOG = [
  { key:'bench', name:'實驗桌', wMm: 1200, dMm: 600,  hMm: 800,  color:'#3b82f6' },
  { key:'hood',  name:'排煙櫃', wMm: 1000, dMm: 800,  hMm: 2000, color:'#ef4444' },
  { key:'sink',  name:'洗滌槽', wMm: 900,  dMm: 600,  hMm: 900,  color:'#22c55e' },
  { key:'fridge', name:'冰箱', wMm: 700,  dMm: 700,  hMm: 1800, color:'#60a5fa' },
  { key:'centrifuge', name:'離心機', wMm: 600, dMm: 600, hMm: 900, color:'#f59e0b' },
  { key:'ultra_low_freezer', name:'超低溫冰箱', wMm: 800, dMm: 800, hMm: 2000, color:'#38bdf8' },
  { key:'incubator', name:'培養箱', wMm: 700, dMm: 600, hMm: 1600, color:'#a78bfa' },
];
const DEVICE_BY_KEY = new Map(DEVICE_CATALOG.map(d => [d.key, d]));

function renderDeviceCatalog(){
  const section = document.getElementById('device-catalog');
  const title = section.querySelector('.tool-section-title');
  section.innerHTML = '';
  section.appendChild(title);

  DEVICE_CATALOG.forEach(d => {
    const div = document.createElement('div');
    div.className = 'item';
    div.textContent = d.name;
    div.onclick = () => addDeviceFromCatalog(d.key);
    section.appendChild(div);
  });
}

/* ===========================
 * Konva 2D
 * =========================== */
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth - 600,
  height: window.innerHeight
});
const gridLayer = new Konva.Layer();
const layer = new Konva.Layer();
stage.add(gridLayer);
stage.add(layer);

const tr = new Konva.Transformer({ keepRatio: false });
layer.add(tr);

let selectedNodes = [];
let selectedNode = null;

let gridVisible = true;
let snapEnabled = true;

function snapPx(v){ return Math.round(v / GRID_PX) * GRID_PX; }

function drawGrid(){
  gridLayer.destroyChildren();
  if(!gridVisible){ gridLayer.draw(); return; }
  const w = stage.width(), h = stage.height();
  for(let x=0; x<=w; x+=GRID_PX) gridLayer.add(new Konva.Line({ points:[x,0,x,h], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  for(let y=0; y<=h; y+=GRID_PX) gridLayer.add(new Konva.Line({ points:[0,y,w,y], stroke:'rgba(15,23,42,0.08)', strokeWidth:1 }));
  gridLayer.draw();
}

/* Room boundary 2D */
let roomRect2D = null;
function drawRoomBoundary2D(){
  if(roomRect2D) roomRect2D.destroy();
  const wPx = mmToPx(ROOM.widthMm);
  const dPx = mmToPx(ROOM.depthMm);
  roomRect2D = new Konva.Rect({
    x: snapPx((stage.width() - wPx)/2),
    y: snapPx((stage.height() - dPx)/2),
    width: wPx,
    height: dPx,
    stroke: 'rgba(15,23,42,0.45)',
    strokeWidth: 2,
    fill: 'rgba(15,23,42,0.03)',
    listening:false,
    name:'room-boundary'
  });
  gridLayer.add(roomRect2D);
  gridLayer.draw();
}
function getRoomRectPx(){ if(!roomRect2D) drawRoomBoundary2D(); return roomRect2D.getClientRect(); }

/* selection rectangle */
let selecting=false, selectionRect, startPos=null;
selectionRect = new Konva.Rect({
  x:0,y:0,width:0,height:0,
  fill:'rgba(59,130,246,0.12)',
  stroke:'rgba(59,130,246,0.9)',
  strokeWidth:1,
  visible:false,
  listening:false
});
layer.add(selectionRect);

/* Nodes */
function addZone(name){
  createNode('zone', name, mmToPx(3000), mmToPx(2000), 0, 'rgba(59,130,246,0.1)', '#3b82f6', 'zone');
}
function addDeviceFromCatalog(key){
  const d = DEVICE_BY_KEY.get(key);
  if(!d) return;
  addDevice(d.name, mmToPx(d.wMm), mmToPx(d.dMm), mmToPx(d.hMm), d.color, d.key);
}
function addDevice(name, wPx, dPx, hPx, color, deviceKey){
  createNode('device', name, wPx, dPx, hPx, color, '#1e293b', deviceKey || 'device');
}
function createNode(type, name, wPx, dPx, hPx, fill, stroke, deviceKey){
  const group = new Konva.Group({
    x: 100, y: 100, draggable: true, name: type,
    customData: { height3dPx: hPx||0, deviceKey: deviceKey }
  });
  const rect = new Konva.Rect({ width:wPx, height:dPx, fill, stroke, name:'main-rect', dash: type==='zone' ? [10,5] : [] });
  const title = new Konva.Text({ text:name, fontSize:14, fill:stroke, padding:8, name:'title-text' });
  const dim = new Konva.Text({ text:'', fontSize:10, fill:stroke, name:'dim-label' });
  group.add(rect,title,dim);
  updateUI(group);

  group.on('dragmove', () => {
    if(snapEnabled) group.position({ x:snapPx(group.x()), y:snapPx(group.y()) });
    constrainToRoom(group);
    updateUI(group);
    scheduleAutosave();
  });
  group.on('dragend', () => scheduleAutosave());
  group.on('transform', () => { updateUI(group); scheduleAutosave(); });
  group.on('transformend', () => {
    if(snapEnabled) normalizeGroupToGrid(group);
    constrainToRoom(group);
    scheduleAutosave();
    if(is3DVisible()) update3D();
  });
  group.on('click tap', (e) => {
    e.cancelBubble = true;
    const multi = e.evt && e.evt.shiftKey;
    if(multi) toggleSelectNode(group); else selectSingleNode(group);
  });

  layer.add(group);
  if(type==='zone') group.moveToBottom();
  selectSingleNode(group);
  layer.draw();
  scheduleAutosave();
  if(is3DVisible()) update3D();
}
function normalizeGroupToGrid(group){
  group.x(snapPx(group.x())); group.y(snapPx(group.y()));
  const rect = group.findOne('.main-rect');
  const absW = rect.width()*group.scaleX();
  const absH = rect.height()*group.scaleY();
  const targetW = Math.max(GRID_PX, snapPx(absW));
  const targetH = Math.max(GRID_PX, snapPx(absH));
  group.scaleX(targetW/rect.width());
  group.scaleY(targetH/rect.height());
}
function constrainToRoom(group){
  if(!roomRect2D) return;
  const rr = getRoomRectPx();
  const r = group.findOne('.main-rect');
  const w = r.width()*group.scaleX();
  const h = r.height()*group.scaleY();
  let x = clamp(group.x(), rr.x, rr.x + rr.width - w);
  let y = clamp(group.y(), rr.y, rr.y + rr.height - h);
  group.position({x,y});
}
function updateUI(group){
  const rect = group.findOne('.main-rect');
  const dim = group.findOne('.dim-label');
  const wPx = rect.width()*group.scaleX();
  const dPx = rect.height()*group.scaleY();
  dim.text(`${fmtMm(pxToMm(wPx))} x ${fmtMm(pxToMm(dPx))}`);
  dim.x(rect.width() - dim.width() - 5);
  dim.y(rect.height() - 15);
  if(selectedNodes.includes(group)) renderInspector();
}

/* selection */
function applyTransformer(){
  tr.nodes(selectedNodes);
  layer.draw();
  sync3DSelectionHighlight();
}
function clearSelection(){
  selectedNodes=[]; selectedNode=null;
  applyTransformer();
  renderInspector();
}
function selectSingleNode(node){
  selectedNodes=[node]; selectedNode=node;
  applyTransformer(); renderInspector();
}
function toggleSelectNode(node){
  const idx = selectedNodes.indexOf(node);
  if(idx>=0) selectedNodes.splice(idx,1); else selectedNodes.push(node);
  selectedNode = selectedNodes.length===1 ? selectedNodes[0] : null;
  applyTransformer(); renderInspector();
}

/* marquee */
stage.on('click tap', (e) => { if(e.target===stage){ clearSelection(); if(is3DVisible()) update3D(); }});
stage.on('mousedown touchstart', (e) => {
  if(is3DVisible()) return;
  if(e.target!==stage) return;
  if(e.evt && (e.evt.button!==undefined) && e.evt.button!==0) return;
  selecting=true;
  startPos = stage.getPointerPosition();
  selectionRect.visible(true);
  selectionRect.position(startPos);
  selectionRect.size({width:0,height:0});
  layer.draw();
});
stage.on('mousemove touchmove', () => {
  if(!selecting) return;
  const pos = stage.getPointerPosition(); if(!pos) return;
  const x = Math.min(startPos.x,pos.x);
  const y = Math.min(startPos.y,pos.y);
  const w = Math.abs(pos.x-startPos.x);
  const h = Math.abs(pos.y-startPos.y);
  selectionRect.setAttrs({x,y,width:w,height:h});
  layer.batchDraw();
});
stage.on('mouseup touchend', (e) => {
  if(!selecting) return;
  selecting=false;
  selectionRect.visible(false);
  layer.draw();
  const box = selectionRect.getClientRect();
  const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'));
  const additive = e.evt && e.evt.shiftKey;
  const hits = groups.filter(g => Konva.Util.haveIntersection(box, g.getClientRect()));
  if(!additive) selectedNodes=[];
  hits.forEach(g => { if(!selectedNodes.includes(g)) selectedNodes.push(g); });
  selectedNode = selectedNodes.length===1 ? selectedNodes[0] : null;
  applyTransformer(); renderInspector();
  if(is3DVisible()) update3D();
});

/* inspector (minimal, keep stable) */
function renderInspector(mode){
  const container = document.getElementById('inspector-content');

  if(mode === 'room'){
    container.innerHTML = `
      <div class="chip">矩形房間設定</div>
      <div class="prop-grid" style="margin-top:12px;">
        <div class="prop-group"><label class="prop-label">寬度 (mm)</label><input type="number" value="${ROOM.widthMm}" oninput="updateRoom('widthMm', this.value)"></div>
        <div class="prop-group"><label class="prop-label">長度 (mm)</label><input type="number" value="${ROOM.depthMm}" oninput="updateRoom('depthMm', this.value)"></div>
        <div class="prop-group"><label class="prop-label">牆高 (mm)</label><input type="number" value="${ROOM.wallHeightMm}" oninput="updateRoom('wallHeightMm', this.value)"></div>
        <div class="prop-group"><label class="prop-label">牆厚 (mm)</label><input type="number" value="${ROOM.wallThicknessMm}" disabled></div>
      </div>
      <div class="hint" style="margin-top:10px;">3D 會生成地板與四面牆。</div>
      <button class="btn-action" style="background:#334155" onclick="toast('已套用房間設定');">完成</button>
    `;
    return;
  }

  if(selectedNodes.length === 0){
    container.innerHTML = `<div class="chip">請選擇物件</div><div class="hint">左鍵拖曳空白處可框選，Shift 可多選。</div>`;
    return;
  }
  if(selectedNodes.length > 1){
    container.innerHTML = `<div class="chip">已選取：${selectedNodes.length} 個物件</div><button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除選取</button>`;
    return;
  }

  const n = selectedNodes[0];
  const r = n.findOne('.main-rect');
  const wPx = r.width()*n.scaleX();
  const dPx = r.height()*n.scaleY();
  const hPx = n.attrs.customData?.height3dPx || 0;
  const key = n.attrs.customData?.deviceKey || n.name();

  container.innerHTML = `
    <div class="chip">已選取：1 個物件</div>
    <div class="hint" style="margin-top:10px;">
      類別：<b>${escapeHtml(key)}</b><br/>
      尺寸：<b>${fmtMm(pxToMm(wPx))}×${fmtMm(pxToMm(dPx))}</b><br/>
      高度：<b>${fmtCm(pxToMm(hPx))}</b>
    </div>
    <button class="btn-action" style="background:var(--danger)" onclick="deleteSelected()">刪除物件</button>
  `;
}

function updateRoom(p, v){
  const mm = Math.max(1000, safeInt(v, ROOM[p]));
  ROOM[p] = mm;
  drawGrid();
  drawRoomBoundary2D();
  scheduleAutosave();
  if(is3DVisible()) update3D();
}

/* delete/export */
function deleteSelected(){
  if(selectedNodes.length===0) return;
  selectedNodes.forEach(n => n.destroy());
  clearSelection();
  layer.draw();
  scheduleAutosave();
  if(is3DVisible()) update3D();
}

function exportImg(f){
  tr.nodes([]); layer.draw();
  if(f==='png'){
    const a=document.createElement('a');
    a.download='lab.png';
    a.href=stage.toDataURL();
    a.click();
  }else{
    const doc = new window.jspdf.jsPDF('l','px',[stage.width(), stage.height()]);
    doc.addImage(stage.toDataURL(), 'PNG', 0,0, stage.width(), stage.height());
    doc.save('lab.pdf');
  }
}

/* save/load */
const STORAGE_KEY='labcad_design_v1';
let autosaveTimer=null;
function scheduleAutosave(){
  clearTimeout(autosaveTimer);
  autosaveTimer=setTimeout(() => {
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(getDesignJSON())); }
    catch(err){ console.error(err); toast('自動保存失敗'); }
  }, 150);
}
function serializeNode(group){
  const r = group.findOne('.main-rect');
  const title = group.findOne('.title-text');
  const wPx = r.width()*group.scaleX();
  const dPx = r.height()*group.scaleY();
  const hPx = group.attrs.customData?.height3dPx || 0;
  return {
    type: group.name(),
    key: group.attrs.customData?.deviceKey || group.name(),
    name: title ? title.text() : '',
    xMm: pxToMm(group.x()),
    yMm: pxToMm(group.y()),
    wMm: pxToMm(wPx),
    dMm: pxToMm(dPx),
    rot: group.rotation(),
    fill: r.fill(),
    stroke: r.stroke(),
    dash: r.dash(),
    hMm: pxToMm(hPx)
  };
}
function getDesignJSON(){
  const nodes = layer.getChildren()
    .filter(n => n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone'))
    .map(serializeNode);
  return {
    version: 62,
    savedAt: new Date().toISOString(),
    units: { gridPx: GRID_PX, mmPerGrid: MM_PER_GRID },
    room: { ...ROOM },
    ui: { gridVisible, snapEnabled },
    nodes
  };
}
function downloadText(filename, text, mime='application/json'){
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
function exportDesignJSON(){ downloadText('labcad-design.json', JSON.stringify(getDesignJSON(), null, 2)); toast('已匯出 JSON'); }
function tryLoadFromLocalStorage(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{ loadDesignFromObject(JSON.parse(raw)); toast('已從自動保存載入'); }
  catch(err){ console.warn(err); }
}
function loadDesignFromObject(design){
  if(!design || !Array.isArray(design.nodes)) return;
  // clear
  layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone')).forEach(g => g.destroy());
  clearSelection();

  if(design.room){
    ROOM.widthMm = design.room.widthMm ?? ROOM.widthMm;
    ROOM.depthMm = design.room.depthMm ?? ROOM.depthMm;
    ROOM.wallHeightMm = design.room.wallHeightMm ?? ROOM.wallHeightMm;
    ROOM.wallThicknessMm = design.room.wallThicknessMm ?? ROOM.wallThicknessMm;
  }

  design.nodes.forEach(n => {
    const type = n.type === 'zone' ? 'zone' : 'device';
    const stroke = n.stroke || (type==='zone' ? '#3b82f6' : '#1e293b');
    const dash = Array.isArray(n.dash) ? n.dash : (type==='zone' ? [10,5] : []);
    const fill = n.fill || (type==='zone' ? 'rgba(59,130,246,0.1)' : '#3b82f6');

    const group = new Konva.Group({
      x: mmToPx(Number(n.xMm) || 0),
      y: mmToPx(Number(n.yMm) || 0),
      draggable: true,
      name: type,
      customData: { height3dPx: mmToPx(Number(n.hMm)||0), deviceKey: n.key || type }
    });

    const rect = new Konva.Rect({
      width: mmToPx(Math.max(100, Number(n.wMm) || 1000)),
      height: mmToPx(Math.max(100, Number(n.dMm) || 1000)),
      fill, stroke, name:'main-rect', dash
    });

    const title = new Konva.Text({ text:n.name || '', fontSize:14, fill:stroke, padding:8, name:'title-text' });
    const dim = new Konva.Text({ text:'', fontSize:10, fill:stroke, name:'dim-label' });
    group.rotation(Number(n.rot)||0);
    group.add(rect,title,dim);
    updateUI(group);

    group.on('dragmove', () => {
      if(snapEnabled) group.position({ x:snapPx(group.x()), y:snapPx(group.y()) });
      constrainToRoom(group);
      updateUI(group);
      scheduleAutosave();
    });
    group.on('dragend', () => scheduleAutosave());
    group.on('transform', () => { updateUI(group); scheduleAutosave(); });
    group.on('transformend', () => {
      if(snapEnabled) normalizeGroupToGrid(group);
      constrainToRoom(group);
      scheduleAutosave();
      if(is3DVisible()) update3D();
    });
    group.on('click tap', (e) => {
      e.cancelBubble = true;
      const multi = e.evt && e.evt.shiftKey;
      if(multi) toggleSelectNode(group); else selectSingleNode(group);
    });

    layer.add(group);
    if(type==='zone') group.moveToBottom();
  });

  drawGrid(); drawRoomBoundary2D(); layer.draw();
  if(is3DVisible()) update3D();
}

/* ===========================
 * 3D Prefabs (RoundedBoxGeometry)
 * =========================== */
function stdMat(hex, opts={}){
  const m = new THREE.MeshStandardMaterial({
    color: new THREE.Color(hex),
    roughness: opts.roughness ?? 0.7,
    metalness: opts.metalness ?? 0.05,
    transparent: !!opts.transparent,
    opacity: opts.opacity ?? 1
  });
  if(opts.emissive){
    m.emissive = new THREE.Color(opts.emissive);
    m.emissiveIntensity = opts.emissiveIntensity ?? 0.6;
  }
  return m;
}

function makeRoundedBox(w, h, d, radius, smooth=3, mat){
  const g = new RoundedBoxGeometry(w, h, d, smooth, radius);
  const m = new THREE.Mesh(g, mat);
  m.castShadow = true;
  m.receiveShadow = true;
  return m;
}

function makeHandle(x, y, z, len, vertical=true){
  const geo = new THREE.CylinderGeometry(7, 7, len, 12);
  const mat = stdMat('#cbd5e1', { roughness:0.28, metalness:0.75 });
  const m = new THREE.Mesh(geo, mat);
  if(!vertical) m.rotation.z = Math.PI/2;
  m.position.set(x,y,z);
  m.castShadow = true;
  return m;
}

function makePanel(x, y, z, w, h){
  const geo = new RoundedBoxGeometry(w, h, 10, 2, Math.min(8, w*0.08));
  const mat = stdMat('#0b1220', { roughness:0.5, metalness:0.05, emissive:'#60a5fa', emissiveIntensity:0.85 });
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x,y,z);
  m.castShadow = false;
  return m;
}

function buildBench(w, d, h){
  const root = new THREE.Group();

  const top = makeRoundedBox(w, 44, d, 16, 3, stdMat('#f1f5f9', { roughness:0.88, metalness:0.02 }));
  top.position.set(0, h - 22, 0);
  root.add(top);

  // frame + legs
  const legH = h - 70;
  const legMat = stdMat('#334155', { roughness:0.92, metalness:0.08 });
  const legGeo = new RoundedBoxGeometry(28, legH, 28, 1, 6);
  const offsets = [
    [-w/2+26, legH/2, -d/2+26],
    [ w/2-26, legH/2, -d/2+26],
    [-w/2+26, legH/2,  d/2-26],
    [ w/2-26, legH/2,  d/2-26],
  ];
  offsets.forEach(([x,y,z]) => {
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(x,y,z);
    leg.castShadow = true;
    root.add(leg);
  });

  const frame = makeRoundedBox(w-60, 20, 20, 6, 1, legMat);
  frame.position.set(0, 130, -d/2 + 22);
  root.add(frame);

  return { root, pickHeight: h };
}

function buildCabinetLike(w, d, h, bodyHex, withGlass=false){
  const root = new THREE.Group();
  const body = makeRoundedBox(w, h, d, Math.min(22, Math.min(w,d)*0.08), 3, stdMat(bodyHex, { roughness:0.78, metalness:0.05 }));
  body.position.set(0, h/2, 0);
  root.add(body);

  // door seam
  const seam = makeRoundedBox(w*0.9, h*0.88, 2, 10, 1, stdMat('#0b1220', { roughness:1.0, metalness:0.0, transparent:true, opacity:0.55 }));
  seam.position.set(0, h/2, d/2 + 1);
  root.add(seam);

  // handle
  root.add(makeHandle(w/2 - 36, h/2, d/2 + 14, h*0.45, true));

  // top panel
  root.add(makePanel(0, h - 120, d/2 + 12, w*0.5, 74));

  // glass overlay (incubator)
  if(withGlass){
    const glass = makeRoundedBox(w*0.82, h*0.74, 8, 18, 2, stdMat('#93c5fd', { transparent:true, opacity:0.16, roughness:0.15, metalness:0.0 }));
    glass.position.set(0, h/2, d/2 + 8);
    glass.castShadow = false;
    root.add(glass);
  }

  // feet
  const footGeo = new THREE.CylinderGeometry(10, 10, 18, 12);
  const footMat = stdMat('#0f172a', { roughness:0.9, metalness:0.1 });
  const corners = [
    [-w/2+22, 10, -d/2+22],
    [ w/2-22, 10, -d/2+22],
    [-w/2+22, 10,  d/2-22],
    [ w/2-22, 10,  d/2-22],
  ];
  corners.forEach(([x,y,z]) => {
    const f = new THREE.Mesh(footGeo, footMat);
    f.position.set(x,y,z);
    f.castShadow = true;
    root.add(f);
  });

  return { root, pickHeight: h };
}

function buildCentrifuge(w, d, h){
  const root = new THREE.Group();
  const baseH = h*0.55;
  const base = makeRoundedBox(w, baseH, d, Math.min(18, Math.min(w,d)*0.08), 3, stdMat('#f1f5f9', { roughness:0.82 }));
  base.position.set(0, baseH/2, 0);
  root.add(base);

  const lid = new THREE.Mesh(
    new THREE.CylinderGeometry(Math.min(w,d)*0.38, Math.min(w,d)*0.38, h*0.28, 28),
    stdMat('#cbd5e1', { roughness:0.55, metalness:0.08 })
  );
  lid.position.set(0, baseH + (h*0.14), 0);
  lid.castShadow = true;
  root.add(lid);

  root.add(makePanel(w*0.22, baseH*0.65, d/2 + 14, w*0.38, h*0.22));
  return { root, pickHeight: h };
}

function buildSink(w, d, h){
  const root = new THREE.Group();
  const top = makeRoundedBox(w, 44, d, 16, 3, stdMat('#f1f5f9', { roughness:0.9 }));
  top.position.set(0, h - 22, 0);
  root.add(top);

  const basin = makeRoundedBox(w*0.55, 26, d*0.45, 14, 2, stdMat('#cbd5e1', { roughness:0.4, metalness:0.28 }));
  basin.position.set(-w*0.08, h - 30, 0);
  root.add(basin);

  const post = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 120, 14), stdMat('#94a3b8', { roughness:0.3, metalness:0.75 }));
  post.position.set(w*0.2, h + 30, 0);
  post.castShadow = true;
  root.add(post);

  const spout = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, 120, 14), post.material);
  spout.rotation.z = Math.PI/2;
  spout.position.set(w*0.2 + 55, h + 70, 0);
  spout.castShadow = true;
  root.add(spout);

  const cab = makeRoundedBox(w*0.92, h-60, d*0.92, 16, 3, stdMat('#f8fafc', { roughness:0.9 }));
  cab.position.set(0, (h-60)/2, 0);
  root.add(cab);
  root.add(makeHandle(w*0.35, (h-60)/2, d/2 + 14, (h-60)*0.35, true));

  return { root, pickHeight: h };
}

function buildHood(w, d, h){
  const root = new THREE.Group();
  const body = makeRoundedBox(w, h, d, Math.min(22, Math.min(w,d)*0.08), 3, stdMat('#f1f5f9', { roughness:0.9 }));
  body.position.set(0, h/2, 0);
  root.add(body);

  const glass = makeRoundedBox(w*0.9, h*0.55, 10, 16, 2, stdMat('#93c5fd', { transparent:true, opacity:0.18, roughness:0.12, metalness:0.0 }));
  glass.position.set(0, h*0.55, d/2 + 12);
  glass.castShadow = false;
  root.add(glass);

  root.add(makePanel(0, h - 140, d/2 + 16, w*0.6, 84));

  const base = makeRoundedBox(w, 46, d, 14, 2, stdMat('#94a3b8', { roughness:0.95, metalness:0.05 }));
  base.position.set(0, 23, 0);
  root.add(base);

  return { root, pickHeight: h };
}

function buildPrefab(key, w, d, h){
  // mid-rounded corners (level 2)
  switch(key){
    case 'bench': return buildBench(w, d, mmToPx(800));
    case 'fridge': return buildCabinetLike(w, d, h, '#f8fafc', false);
    case 'ultra_low_freezer': return buildCabinetLike(w, d, h, '#e2e8f0', false);
    case 'incubator': return buildCabinetLike(w, d, h, '#f8fafc', true);
    case 'centrifuge': return buildCentrifuge(w, d, h);
    case 'sink': return buildSink(w, d, mmToPx(900));
    case 'hood': return buildHood(w, d, h);
    default: return buildCabinetLike(w, d, h, '#e5e7eb', false);
  }
}

/* ===========================
 * 3D Engine (picking + highlight + room)
 * =========================== */
let sc, cam, rend, ctrl;
let objectsGroup, roomGroup3D, dirLight, groundMesh;

const threeMap = new Map(); // id -> { root, pickMesh, outline, key }
const pickables = [];

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function is3DVisible(){
  const c3d = document.getElementById('three-container');
  return c3d && c3d.style.display === 'block';
}
function get3DSize(){
  const c3d = document.getElementById('three-container');
  return { w: Math.max(1, c3d.clientWidth || 0), h: Math.max(1, c3d.clientHeight || 0) };
}
function resize3D(){
  if(!rend || !cam) return;
  const { w, h } = get3DSize();
  rend.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  rend.setSize(w, h, false);
  cam.aspect = w / h;
  cam.updateProjectionMatrix();
  updateDebug3D();
}

function init3DIfNeeded(){
  const c3d = document.getElementById('three-container');
  if(sc) return;

  sc = new THREE.Scene();
  sc.background = new THREE.Color(0x0a0f1a);

  const { w, h } = get3DSize();
  cam = new THREE.PerspectiveCamera(45, w / h, 1, 20000);
  cam.position.set(1000, 1000, 1000);

  rend = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  rend.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  rend.setSize(w, h, false);
  rend.shadowMap.enabled = true;
  rend.shadowMap.type = THREE.PCFSoftShadowMap;
  c3d.appendChild(rend.domElement);

  ctrl = new OrbitControls(cam, rend.domElement);
  ctrl.enableDamping = true;
  ctrl.dampingFactor = 0.08;
  ctrl.target.set(0, 0, 0);
  ctrl.update();

  sc.add(new THREE.AmbientLight(0xffffff, 0.55));

  dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(1200, 1800, 900);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 12000;
  dirLight.shadow.camera.left = -5000;
  dirLight.shadow.camera.right = 5000;
  dirLight.shadow.camera.top = 5000;
  dirLight.shadow.camera.bottom = -5000;
  sc.add(dirLight);

  const groundGeo = new THREE.PlaneGeometry(12000, 12000);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.95, metalness: 0.0 });
  groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI / 2;
  groundMesh.position.y = 0;
  groundMesh.receiveShadow = true;
  sc.add(groundMesh);

  sc.add(new THREE.GridHelper(8000, 80, 0x334155, 0x1e293b));

  roomGroup3D = new THREE.Group();
  sc.add(roomGroup3D);

  objectsGroup = new THREE.Group();
  sc.add(objectsGroup);

  rend.domElement.addEventListener('pointerdown', onPointerDown3D);

  updateDebug3D();
}

function buildRoom3D(){
  // clear roomGroup3D
  for(let i = roomGroup3D.children.length-1; i>=0; i--) roomGroup3D.remove(roomGroup3D.children[i]);

  const w = mmToPx(ROOM.widthMm);
  const d = mmToPx(ROOM.depthMm);
  const wallH = mmToPx(ROOM.wallHeightMm);
  const t = mmToPx(ROOM.wallThicknessMm);

  const wallMat = new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 0.9, metalness: 0.0 });
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.95, metalness: 0.0 });

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(w, d), floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  roomGroup3D.add(floor);

  const wallGeo1 = new THREE.BoxGeometry(w, wallH, t);
  const wallGeo2 = new THREE.BoxGeometry(t, wallH, d);

  const wallN = new THREE.Mesh(wallGeo1, wallMat); wallN.position.set(0, wallH/2, -d/2);
  const wallS = new THREE.Mesh(wallGeo1, wallMat); wallS.position.set(0, wallH/2, d/2);
  const wallW = new THREE.Mesh(wallGeo2, wallMat); wallW.position.set(-w/2, wallH/2, 0);
  const wallE = new THREE.Mesh(wallGeo2, wallMat); wallE.position.set(w/2, wallH/2, 0);

  [wallN, wallS, wallW, wallE].forEach(wm => { wm.castShadow=true; wm.receiveShadow=true; roomGroup3D.add(wm); });
}

function update3D(){
  if(!sc) return;

  buildRoom3D();

  // clear objects
  while(objectsGroup.children.length) objectsGroup.remove(objectsGroup.children[0]);
  threeMap.clear();
  pickables.length = 0;

  const roomRect = getRoomRectPx();
  const roomWpx = mmToPx(ROOM.widthMm);
  const roomDpx = mmToPx(ROOM.depthMm);
  const roomCenterX = roomRect.x + roomRect.width/2;
  const roomCenterY = roomRect.y + roomRect.height/2;

  const groups = layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device' || n.name()==='zone'));

  groups.forEach(n => {
    const r = n.findOne('.main-rect');
    const wPx = r.width() * n.scaleX();
    const dPx = r.height() * n.scaleY();
    const hPx = n.attrs.customData?.height3dPx || mmToPx(800);

    const center2dX = n.x() + wPx/2;
    const center2dY = n.y() + dPx/2;

    const x3d = center2dX - roomCenterX;
    const z3d = center2dY - roomCenterY;

    const id = n._id;
    const key = n.attrs.customData?.deviceKey || n.name();

    if(n.name() === 'device'){
      const prefab = buildPrefab(key, wPx, dPx, hPx);
      const root = prefab.root;

      root.position.set(x3d, 0, z3d);
      root.rotation.y = -THREE.MathUtils.degToRad(n.rotation());

      root.traverse((obj) => {
        if(obj.isMesh){
          obj.castShadow = true;
          obj.receiveShadow = true;
        }
      });

      // pick volume
      const pickGeo = new THREE.BoxGeometry(wPx, prefab.pickHeight ?? hPx, dPx);
      const pickMat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0 });
      const pickMesh = new THREE.Mesh(pickGeo, pickMat);
      pickMesh.position.set(0, (prefab.pickHeight ?? hPx)/2, 0);
      pickMesh.userData = { konvaId: id, kind:'device' };
      root.add(pickMesh);

      // outline
      const outline = new THREE.LineSegments(
        new THREE.EdgesGeometry(pickGeo),
        new THREE.LineBasicMaterial({ color: 0x93c5fd, transparent:true, opacity:0.95 })
      );
      outline.position.copy(pickMesh.position);
      outline.visible = false;
      root.add(outline);

      objectsGroup.add(root);
      threeMap.set(id, { root, pickMesh, outline, key });
      pickables.push(pickMesh);

    }else{
      const mat = new THREE.MeshStandardMaterial({
        color: 0x3b82f6, transparent:true, opacity:0.18,
        roughness: 0.95, metalness:0.0, side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(wPx, dPx), mat);
      mesh.rotation.x = -Math.PI/2;
      mesh.position.set(x3d, 1, z3d);
      mesh.userData = { konvaId: id, kind:'zone' };

      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(mesh.geometry),
        new THREE.LineBasicMaterial({ color: 0x60a5fa, transparent:true, opacity:0.9 })
      );
      edges.rotation.copy(mesh.rotation);
      edges.position.copy(mesh.position);
      edges.visible = false;

      const root = new THREE.Group();
      root.add(mesh);
      root.add(edges);
      objectsGroup.add(root);

      threeMap.set(id, { root, pickMesh: mesh, outline: edges, key: 'zone', zoneMesh: mesh });
      pickables.push(mesh);
    }
  });

  fitCameraToRoom(roomWpx, roomDpx);
  sync3DSelectionHighlight();
  updateDebug3D();
}

function sync3DSelectionHighlight(){
  const sel = new Set(selectedNodes.map(n => n._id));
  threeMap.forEach((obj, id) => {
    const selected = sel.has(id);
    obj.outline.visible = selected;

    if(obj.zoneMesh){
      obj.zoneMesh.material.opacity = selected ? 0.28 : 0.18;
      return;
    }

    obj.root.traverse((m) => {
      if(!m.isMesh) return;
      if(m === obj.pickMesh) return;
      if(m.material && m.material.emissive){
        m.material.emissive.setHex(selected ? 0x1d4ed8 : 0x000000);
        m.material.emissiveIntensity = selected ? 0.12 : 0.0;
      }
    });
  });
}

function fitCameraToRoom(roomWpx, roomDpx){
  const maxDim = Math.max(roomWpx, roomDpx);
  const center = new THREE.Vector3(0,0,0);
  ctrl.target.copy(center);
  const fov = cam.fov * (Math.PI/180);
  let dist = Math.abs(maxDim/2/Math.tan(fov/2));
  dist *= 1.35;
  const dir = new THREE.Vector3(1,1,1).normalize();
  cam.position.copy(center.clone().add(dir.multiplyScalar(dist)));
  cam.near = Math.max(1, dist/100);
  cam.far = Math.max(20000, dist*10);
  cam.updateProjectionMatrix();
  ctrl.update();
}

function animate3D(){
  if(is3DVisible()){
    requestAnimationFrame(animate3D);
    ctrl.update();
    rend.render(sc, cam);
  }
}

function updateDebug3D(){
  const debug = document.getElementById('debug3d');
  if(!debug || !is3DVisible()) return;
  const { w, h } = get3DSize();
  debug.textContent =
    `3D: ${w} x ${h}\n` +
    `Room: ${ROOM.widthMm}x${ROOM.depthMm}mm\n` +
    `Objects: ${threeMap.size}\n` +
    `Selected: ${selectedNodes.length}\n`;
}

/* picking + info card */
function onPointerDown3D(e){
  if(!is3DVisible() || !cam) return;
  const rect = rend.domElement.getBoundingClientRect();
  const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
  pointer.set(x, y);
  raycaster.setFromCamera(pointer, cam);

  const hits = raycaster.intersectObjects(pickables, false);
  if(hits.length === 0){
    hideInfoCard();
    if(!e.shiftKey){ clearSelection(); layer.draw(); }
    return;
  }

  const hit = hits[0].object;
  const konvaId = hit.userData?.konvaId;
  if(!konvaId) return;

  const node = layer.getChildren().find(n => n instanceof Konva.Group && n._id === konvaId);
  if(!node) return;

  if(e.shiftKey) toggleSelectNode(node);
  else selectSingleNode(node);
  layer.draw();

  showInfoCardFor(node, { x: e.clientX, y: e.clientY });
}

function getNodeSizeMm(node){
  const r = node.findOne('.main-rect');
  const wPx = r.width() * node.scaleX();
  const dPx = r.height() * node.scaleY();
  const hPx = node.attrs.customData?.height3dPx || 0;
  return { wMm: pxToMm(wPx), dMm: pxToMm(dPx), hMm: pxToMm(hPx) };
}

function showInfoCardFor(node, pointerClient){
  const card = document.getElementById('info-card');
  const name = node.findOne('.title-text')?.text() || '';
  const key = node.attrs.customData?.deviceKey || node.name();
  const size = getNodeSizeMm(node);

  card.innerHTML = `
    <div class="info-title">
      <div class="info-icon">⟲</div>
      <div style="flex:1;"><div style="font-weight:800;">${escapeHtml(name)}</div></div>
    </div>
    <div class="info-row"><div class="info-key">類別</div><div>${escapeHtml(key)}</div></div>
    <div class="info-row"><div class="info-key">尺寸</div><div>${size.wMm}×${size.dMm}mm</div></div>
    <div class="info-row"><div class="info-key">擺放高度</div><div>${fmtCm(size.hMm)}</div></div>
  `;
  card.style.display = 'block';

  const vw = window.innerWidth, vh = window.innerHeight;
  const cardRect = { w: 300, h: 140 };
  let left = pointerClient.x + 14;
  let top = pointerClient.y + 14;
  if(left + cardRect.w > vw) left = pointerClient.x - cardRect.w - 14;
  if(top + cardRect.h > vh) top = pointerClient.y - cardRect.h - 14;
  card.style.left = `${left}px`;
  card.style.top = `${top}px`;
}
function hideInfoCard(){
  const card = document.getElementById('info-card');
  card.style.display = 'none';
}

/* ===========================
 * UI wiring
 * =========================== */
document.getElementById('room-settings-btn').onclick = () => renderInspector('room');
document.getElementById('add-zone-btn').onclick = () => addZone('新規劃區域');

document.getElementById('btn-export-png').onclick = () => exportImg('png');
document.getElementById('btn-export-pdf').onclick = () => exportImg('pdf');
document.getElementById('btn-delete').onclick = () => deleteSelected();

document.getElementById('btn-export-json').onclick = () => exportDesignJSON();
document.getElementById('btn-import-json').onclick = () => document.getElementById('import-json-input').click();
document.getElementById('btn-reset').onclick = () => resetAll();

document.getElementById('btn-grid').onclick = () => { gridVisible = !gridVisible; drawGrid(); };
document.getElementById('btn-snap').onclick = () => { snapEnabled = !snapEnabled; };

document.getElementById('toggle-3d').onclick = () => {
  const c2d = document.getElementById('container');
  const c3d = document.getElementById('three-container');
  const debug = document.getElementById('debug3d');
  const btn = document.getElementById('toggle-3d');

  const opening = (c3d.style.display === 'none' || c3d.style.display === '');
  if(opening){
    c3d.style.display = 'block';
    c2d.style.display = 'none';
    btn.innerText = '返回 2D';
    debug.style.display = 'block';
    requestAnimationFrame(() => {
      init3DIfNeeded();
      resize3D();
      update3D();
      animate3D();
    });
  }else{
    hideInfoCard();
    c3d.style.display = 'none';
    c2d.style.display = 'block';
    btn.innerText = '查看 3D 預覽';
    debug.style.display = 'none';
  }
};

document.getElementById('import-json-input').addEventListener('change', (e) => {
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try{ loadDesignFromObject(JSON.parse(reader.result)); toast('已匯入 JSON'); }
    catch(err){ console.error(err); toast('匯入失敗'); }
    finally{ e.target.value=''; }
  };
  reader.readAsText(file);
});

function resetAll(){
  layer.getChildren().filter(n => n instanceof Konva.Group && (n.name()==='device'||n.name()==='zone')).forEach(g => g.destroy());
  clearSelection();
  localStorage.removeItem(STORAGE_KEY);
  layer.draw();
  if(is3DVisible()) update3D();
  toast('已清空');
}

window.addEventListener('resize', () => {
  stage.width(window.innerWidth - 600);
  stage.height(window.innerHeight);
  drawGrid();
  drawRoomBoundary2D();
  layer.draw();
  if(is3DVisible()) resize3D();
});

/* ===========================
 * Boot
 * =========================== */
renderDeviceCatalog();
drawGrid();
drawRoomBoundary2D();
renderInspector();
tryLoadFromLocalStorage();
</script>
</body>
</html>
